
CHIPCON.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  00003720  000037b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003720  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000490  00800112  00800112  000037c6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000037c6  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000400  00000000  00000000  000037f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005483  00000000  00000000  00003bf6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000019cf  00000000  00000000  00009079  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001b65  00000000  00000000  0000aa48  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000cb4  00000000  00000000  0000c5b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000dbe  00000000  00000000  0000d264  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005439  00000000  00000000  0000e022  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000600  00000000  00000000  0001345b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * \param[in] p Pointer from where to read the integer.
 * \returns The 32-bit integer read from memory.
 */
uint32_t read32(const uint8_t* p)
{
       0:	0c 94 87 0f 	jmp	0x1f0e	; 0x1f0e <__ctors_end>
    return (((uint32_t) p[3]) << 24) |
           (((uint32_t) p[2]) << 16) |
       4:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
       8:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
       c:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      10:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
           (((uint32_t) p[1]) <<  8) |
           (((uint32_t) p[0]) <<  0);
      14:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
 */
uint32_t read32(const uint8_t* p)
{
    return (((uint32_t) p[3]) << 24) |
           (((uint32_t) p[2]) << 16) |
           (((uint32_t) p[1]) <<  8) |
      18:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
           (((uint32_t) p[0]) <<  0);
}
      1c:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
 * \param[in] partition Discriptor of partition on which the filesystem resides.
 * \returns 0 on error, a FAT filesystem descriptor on success.
 * \see fat_close
 */
struct fat_fs_struct* fat_open(struct partition_struct* partition)
{
      20:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      24:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      28:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      2c:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      30:	0c 94 f1 19 	jmp	0x33e2	; 0x33e2 <__vector_12>
      34:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
    if(!partition ||
      38:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
#else
    struct fat_fs_struct* fs = fat_fs_handles;
    uint8_t i;
    for(i = 0; i < FAT_FS_COUNT; ++i)
    {
        if(!fs->partition)
      3c:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      40:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      44:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
       !partition->device_write_interval
#else
       0
#endif
      )
        return 0;
      48:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
#endif
        return 0;
    }
    
    return fs;
}
      4c:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      50:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      54:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      58:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      5c:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      60:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      64:	0c 94 a4 0f 	jmp	0x1f48	; 0x1f48 <__bad_interrupt>
      68:	00 10       	cpse	r0, r0
      6a:	0b 10       	cpse	r0, r11
      6c:	19 10       	cpse	r1, r9
      6e:	27 10       	cpse	r2, r7
      70:	35 10       	cpse	r3, r5
      72:	54 10       	cpse	r5, r4
      74:	6d 10       	cpse	r6, r13
      76:	7a 10       	cpse	r7, r10
      78:	ea 0f       	add	r30, r26
      7a:	ea 0f       	add	r30, r26
    }
    if(i >= FAT_FS_COUNT)
        return 0;
#endif

    memset(fs, 0, sizeof(*fs));
      7c:	ea 0f       	add	r30, r26
      7e:	ea 0f       	add	r30, r26
      80:	ea 0f       	add	r30, r26
      82:	ea 0f       	add	r30, r26
      84:	f1 0f       	add	r31, r17
      86:	e2 11       	cpse	r30, r2
      88:	cb 11       	cpse	r28, r11

    fs->partition = partition;
      8a:	bd 11       	cpse	r27, r13
      8c:	a6 12       	cpse	r10, r22
      8e:	9e 12       	cpse	r9, r30
      90:	90 12       	cpse	r9, r16
#if FAT_FAT32_SUPPORT
    uint8_t buffer[37];
#else
    uint8_t buffer[25];
#endif
    offset_t partition_offset = (offset_t) partition->offset * 512;
      92:	8a 12       	cpse	r8, r26
      94:	82 12       	cpse	r8, r18
      96:	7b 12       	cpse	r7, r27
      98:	65 12       	cpse	r6, r21
      9a:	55 12       	cpse	r5, r21
      9c:	46 12       	cpse	r4, r22
      9e:	37 12       	cpse	r3, r23
      a0:	12 12       	cpse	r1, r18
      a2:	f8 11       	cpse	r31, r8
      a4:	ec 11       	cpse	r30, r12

000000a6 <__trampolines_end>:
      a6:	27 39       	cpi	r18, 0x97	; 151
      a8:	27 20       	and	r2, r7
    if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
      aa:	76 65       	ori	r23, 0x56	; 86
      ac:	72 73       	andi	r23, 0x32	; 50
      ae:	20 6c       	ori	r18, 0xC0	; 192
      b0:	65 20       	and	r6, r5
      b2:	62 61       	ori	r22, 0x12	; 18
      b4:	73 0a       	sbc	r7, r19
	...

000000b7 <__c.2204>:
      b7:	27 37 27 20 76 65 72 73 20 6c 65 20 68 61 75 74     '7' vers le haut
      c7:	0a 00                                               ..

000000c9 <__c.2202>:
      c9:	27 23 27 20 70 61 67 65 20 73 75 69 76 61 6e 74     '#' page suivant
#if USE_DYNAMIC_MEMORY
        free(fs);
#else
        fs->partition = 0;
#endif
        return 0;
      d9:	65 0a 00                                            e..

000000dc <__c.2200>:
#endif
    offset_t partition_offset = (offset_t) partition->offset * 512;
    if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
        return 0;

    uint16_t bytes_per_sector = read16(&buffer[0x00]);
      dc:	27 2a 27 20 70 61 67 65 20 70 72 65 63 65 64 61     '*' page preceda
    uint16_t reserved_sectors = read16(&buffer[0x03]);
      ec:	6e 74 65 0a 00                                      nte..

000000f1 <__c.2198>:
    uint8_t sectors_per_cluster = buffer[0x02];
      f1:	27 41 27 20 73 65 6c 65 63 74 69 6f 6e 0a 00        'A' selection..

00000100 <credits>:
    uint8_t fat_copies = buffer[0x05];
    uint16_t max_root_entries = read16(&buffer[0x06]);
     100:	43 48 49 50 43 4f 4e 20 56 31 2e 30 0a 43 6f 70     CHIPCON V1.0.Cop
    uint16_t sector_count_16 = read16(&buffer[0x08]);
    uint16_t sectors_per_fat = read16(&buffer[0x0b]);
     110:	79 72 69 67 68 74 20 32 30 31 34 0a 4a 61 63 71     yright 2014.Jacq
    uint32_t sector_count = read32(&buffer[0x15]);
     120:	75 65 73 20 44 65 73 63 68 65 6e 65 73 0a 0a 46     ues Deschenes..F
        sectors_per_fat32 = sectors_per_fat;
    else if(sectors_per_fat32 == 0)
        /* this is neither FAT16 nor FAT32 */
        return 0;
#else
    if(sectors_per_fat == 0)
     130:	41 54 20 64 72 69 76 65 72 0a 43 6f 70 79 72 69     AT driver.Copyri
    uint32_t data_sector_count = sector_count
                                 - reserved_sectors
#if FAT_FAT32_SUPPORT
                                 - sectors_per_fat32 * fat_copies
#else
                                 - (uint32_t) sectors_per_fat * fat_copies
     140:	67 68 74 20 32 30 30 36 2d 32 30 31 32 0a 52 6f     ght 2006-2012.Ro
        return 0;
#endif

    /* determine the type of FAT we have here */
    uint32_t data_sector_count = sector_count
                                 - reserved_sectors
     150:	6c 61 6e 64 20 52 69 65 67 65 6c 0a 00              land Riegel..

0000015d <flash_games>:
#if FAT_FAT32_SUPPORT
                                 - sectors_per_fat32 * fat_copies
#else
                                 - (uint32_t) sectors_per_fat * fat_copies
     15d:	73 6f 6b 6f 62 61 6e 0a 73 70 61 63 65 66 69 67     sokoban.spacefig
#endif
                                 - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
     16d:	68 74 0a 00                                         ht..

00000171 <__c.1737>:
     171:	75 6e 65 20 74 6f 75 63 68 65 2e 2e 2e 00           une touche....

0000017f <inputs>:
     17f:	04 08 10 20                                         ... 

00000183 <outputs>:
     183:	01 04 08 20                                         ... 

00000187 <key_matrix>:
     187:	01 02 03 0a 04 05 06 0b 07 08 09 0c 0e 00 0f 0d     ................

00000197 <sokoban_info>:
    uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
     197:	53 6f 6b 6f 62 61 6e 20 62 79 20 48 61 70 0a 0a     Sokoban by Hap..
	...

000001a8 <sokoban>:
     1a8:	00 ff 22 1b 6e 05 22 2f ec a1 12 37 ed a1 12 7f     ..".n."/...7....
    if(data_cluster_count < 4085)
        /* this is a FAT12, not supported */
        return 0;
    else if(data_cluster_count < 65525)
     1b8:	4a 32 12 04 eb a1 22 3f 12 04 80 00 e0 a4 88 fe     J2...."?........
        /* this is a FAT16 */
        partition->type = PARTITION_TYPE_FAT16;
    else
        /* this is a FAT32 */
        partition->type = PARTITION_TYPE_FAT32;
     1c8:	65 a4 64 4a 00 14 58 22 69 f6 29 d9 95 00 ee f1     e.dJ..X"i.).....

    /* fill header information */
    struct fat_header_struct* header = &fs->header;
    memset(header, 0, sizeof(*header));
     1d8:	07 31 00 12 2f 00 ee 4a 01 12 04 6e 08 12 16 f7     .1../..J...n....
    
    header->size = (offset_t) sector_count * bytes_per_sector;
     1e8:	15 60 01 f0 18 af c8 fa 1e f5 65 a2 f3 f1 65 4e     .`........e...eN
     1f8:	05 12 5f 81 35 4f 00 70 ff 7a ff 85 30 12 65 81     .._.5O.p.z..0.e.

    header->fat_offset = /* jump to partition */
                         partition_offset +
                         /* jump to fat */
                         (offset_t) reserved_sectors * bytes_per_sector;
     208:	44 80 f4 7a 01 f1 55 22 6d a4 4c fa 33 a4 4c f2     D..z..U"m.L.3.L.
    memset(header, 0, sizeof(*header));
    
    header->size = (offset_t) sector_count * bytes_per_sector;

    header->fat_offset = /* jump to partition */
                         partition_offset +
     218:	65 f1 29 dd 95 f2 29 d6 95 a4 88 fa 55 00 ee 22     e.)...).....U.."
    struct fat_header_struct* header = &fs->header;
    memset(header, 0, sizeof(*header));
    
    header->size = (offset_t) sector_count * bytes_per_sector;

    header->fat_offset = /* jump to partition */
     228:	1b 6d 00 6c 00 62 02 f2 18 61 40 22 d5 87 60 61     .m.l.b...a@"..`a
                         partition_offset +
                         /* jump to fat */
                         (offset_t) reserved_sectors * bytes_per_sector;
    header->fat_size = (data_cluster_count + 2) * (partition->type == PARTITION_TYPE_FAT16 ? 2 : 4);
     238:	80 22 d5 84 e0 81 e0 81 64 22 a7 4c 00 13 2d 43     ."......d".L..-C
     248:	18 12 bb 23 0f 12 99 6e 00 23 01 4e 01 23 01 23     ...#...n.#.N.#.#
     258:	01 83 e0 83 23 83 0e 83 0e 00 ee 22 a7 43 18 12     ....#......".C..

    header->sector_size = bytes_per_sector;
    header->cluster_size = (uint16_t) bytes_per_sector * sectors_per_cluster;
     268:	cf 22 e5 7e 04 23 0f 7e ff 3e 00 12 c5 12 99 a4     .".~.#.~.>......
     278:	85 f7 55 12 a3 22 e5 7e 05 8e 0e 8e 0e 86 e0 86     ..U..".~........
#endif
    {
        header->root_dir_offset = /* jump to fats */
                                  header->fat_offset +
                                  /* jump to root directory entries */
                                  (offset_t) fat_copies * sectors_per_fat * bytes_per_sector;
     288:	17 86 06 00 ee 6e 00 23 01 23 01 23 01 23 01 00     .....n.#.#.#.#..

#if FAT_FAT32_SUPPORT
    if(partition->type == PARTITION_TYPE_FAT16)
#endif
    {
        header->root_dir_offset = /* jump to fats */
     298:	ee 6d 08 a4 b4 fc 1e f0 65 8b 00 9c 50 6c ff 7c     .m......e...Pl.|
                                  (offset_t) fat_copies * sectors_per_fat * bytes_per_sector;

        header->cluster_zero_offset = /* jump to root directory entries */
                                      header->root_dir_offset +
                                      /* skip root directory entries */
                                      (offset_t) max_root_entries * 32;
     2a8:	01 4d 00 12 f1 7d ff 8e 0e 8b 0e 8e f1 00 ee 43     .M...}.........C
     2b8:	10 13 19 33 14 13 1b 78 01 79 01 a4 94 f3 1e d6     ...3...x.y......
     2c8:	74 76 04 56 10 00 ee 86 45 77 04 00 ee a4 85 f7     tv.V....Ew......
     2d8:	65 6a 00 22 2f 6b 01 a4 93 f5 65 98 90 14 17 e1     ej."/k....e.....
        header->root_dir_offset = /* jump to fats */
                                  header->fat_offset +
                                  /* jump to root directory entries */
                                  (offset_t) fat_copies * sectors_per_fat * bytes_per_sector;

        header->cluster_zero_offset = /* jump to root directory entries */
     2e8:	a1 14 3c e0 a1 14 40 e3 a1 14 44 e4 a1 14 48 e5     ..<...@...D...H.
    uint32_t cluster_root_dir = read32(&buffer[0x21]);
#endif

    if(sector_count == 0)
    {
        if(sector_count_16 == 0)
     2f8:	a1 14 29 e2 9e 13 35 4c 00 13 35 6b 00 7c ff a4     ..)...5L..5k.|..
    if(data_cluster_count < 4085)
        /* this is a FAT12, not supported */
        return 0;
    else if(data_cluster_count < 65525)
        /* this is a FAT16 */
        partition->type = PARTITION_TYPE_FAT16;
     308:	ac d6 74 7d ff 4d ff 6d 38 a4 4c fd 1e f0 65 8a     ..t}.M.m8.L...e.

    header->fat_offset = /* jump to partition */
                         partition_offset +
                         /* jump to fat */
                         (offset_t) reserved_sectors * bytes_per_sector;
    header->fat_size = (data_cluster_count + 2) * (partition->type == PARTITION_TYPE_FAT16 ? 2 : 4);
     318:	00 f4 15 81 a2 a4 93 f1 1e f5 65 4b 00 23 f3 80     ..........eK.#..
     328:	60 81 70 80 44 81 54 4b 00 13 93 a4 3a 24 07 4e     `.p.D.TK....:$.N
     338:	01 13 33 a2 1a 24 07 4e 00 13 c3 82 00 83 10 82     ..3..$.N........
     348:	44 83 54 4b 00 13 e5 a2 1a 24 0f 4e 01 13 33 7a     D.TK.....$.N..3z
     358:	80 a4 a4 24 07 88 e5 24 0f 88 e4 a4 b0 d0 14 fb     ...$...$........
     368:	18 d2 34 4b 00 13 eb 3c 39 7c 01 80 a0 a4 4c fd     ..4K...<9|....L.
     378:	1e 7d 01 4d 39 6d 00 f0 55 a4 ac d6 74 86 44 87     .}.M9m..U...t.D.
     388:	54 d6 74 13 33 8a 0e 4f 01 13 b1 a4 85 f7 65 a4     T.t.3..O......e.
     398:	ac 13 dd a4 85 f7 55 86 44 87 54 86 44 87 54 85     ......U.D.T.D.T.
     3a8:	b7 84 b7 f5 55 00 ee d0 12 8e f0 d0 12 00 ee d2     ....U...........
     3b8:	32 8e f0 d2 32 00 ee f3 18 60 32 f0 15 22 2f 22     2...2....`2.."/"
     3c8:	1b 4a 32 12 02 22 3f 12 81 f1 18 60 1e f0 15 22     .J2.."?....`..."
     3d8:	2f e5 9e 13 35 3a 00 12 7f 12 00 20 6a 02 13 71     /...5:..... j..q
     3e8:	6a 04 13 71 6a 01 13 71 6a 03 13 71 00 c1 d5 61     j..qj..qj..q...a
     3f8:	f1 1e 75 08 35 58 14 4e 65 28 83 15 33 fe 14 4c     ..u.5X.Ne(..3..L
     408:	6a 01 12 27 fe 79 99 e7 c7 db 0e cd f3 36 6c db     j..'.y.......6l.
     418:	1c cd e3 36 6c db 38 cd b3 36 67 db 70 cd 9b 37     ...6l.8..6g.p..7
     428:	c0 db e0 79 81 e6 07 9e fe 01 80 06 00 00 0f 07     ...y............
     438:	02 02 00 09 07 0a 05 08 00 fc 00 04 00 00 00 00     ................
     448:	f0 f0 f0 f0 00 40 20 00 f0 d0 b0 f0 60 f0 f0 60     .....@ .....`..`
     458:	f0 90 90 f0 6e 00 88 c2 90 18 53 41 84 2a 15 60     ....n.....SA.*.`
     468:	e8 52 8c 15 51 14 40 89 80 8a 44 43 65 28 58 36     .R..Q.@...DCe(X6
     478:	d1 21 51 91 43 64 01 80 c5 40 22 60 59 8c 03 b0     .!Q.Cd...@"`Y...
     488:	30 15 5d 81 28 50 5d 81 aa a0 bb 00 48 28 2e c0     0.].(P].....H(..
     498:	88 52 28 2d 28 82 50 a5 28 82 00 c0 50 8c 00 5c     .R(-(.P.(...P..\
     4a8:	82 45 20 ac 06 46 0a 95 a2 c1 52 85 60 cb 4a 21     .E ..F....R.`.J!
     4b8:	15 28 8a b3 00 29 42 82 bb 60 0a 14 05 98 02 3c     .(...)B..`.....<
     4c8:	9e 83 c5 20 e8 4c 11 90 98 14 01 0a 50 26 05 2d     ... .L......P&.-
     4d8:	ad 0a 21 30 28 58 0d 10 98 14 b4 69 4b 15 0a 30     ..!0(X.....iK..0
     4e8:	16 06 a4 56 06 80 20 0b 03 60 34 05 81 a1 6b 68     ...V.. ..`4...kh
     4f8:	48 c0 d0 04 01 60 71 70 8c 82 44 61 08 11 18 22     H....`qp..Da..."
     508:	35 41 82 30 1a 45 85 40 59 80 14 a1 55 66 00 0a     5A.0.E.@Y...Uf..
     518:	5a 28 cc 00 b4 29 22 45 42 82 c1 52 94 18 2a a2     Z(...)"EB..R..*.
     528:	8c 1d 00 60 f1 20 67 89 02 a3 b0 22 c8 ae c0 a8     ...`. g...."....
     538:	0b b4 06 d1 76 04 4a 2e ca 89 48 89 46 82 02 15     ....v.J...H.F...
     548:	28 80 94 28 20 20 a0 20 45 40 78 81 c4 42 26 02     (..(  . E@x..B&.
     558:	a8 92 29 68 a0 16 04 a1 41 50 15 48 8d 55 28 2a     ..)h....AP.H.U(*
     568:	6c 89 4a 53 6c 88 02 bb 64 4b 44 76 c8 82 a4 44     l.JSl...dKDv...D
     578:	55 00 bb 05 58 42 11 70 40 28 14 a2 09 52 88 50     U...XB.p@(...R.P
     588:	41 0a 50 40 15 4a 88 2a 8b 23 4a 50 50 14 02 8d     A.P@.J.*.#JPP...
     598:	40 45 02 80 52 94 89 04 54 18 13 04 60 4c 11 98     @E..R...T...`L..
     5a8:	98 23 31 30 46 62 60 91 40 9c 83 44 e0 c8 6d 98     .#10Fb`.@..D..m.
     5b8:	14 44 36 cc 09 81 63 30 24 14 36 cc 09 45 0d b3     .D6...c0$.6..E..
     5c8:	01 54 8a 40 52 da 2c 06 22 14 a4 4c 06 94 04 05     .T.@R.,."..L....
     5d8:	90 a1 40 28 52 26 5a 52 23 01 60 4c 16 28 be 15     ..@(R&ZR#.`L.(..
     5e8:	08 dc 8a b0 34 05 2d 02 d0 a5 36 ca 16 d4 02 83     ....4.-...6.....
     5f8:	b6 52 80 96 96 8e d9 54 04 28 03 b6 58 0a 52 94     .R.....T.(..X.R.
     608:	76 ca 01 12 15 db 2a 20 85 28 3b 65 05 12 d2 95     v.....* .(;e....
     618:	76 53 64 42 c0 9c a6 c8 96 d2 da 3a 24 30 34 72     vSdB.......:$04r
     628:	00 91 51 c8 03 07 72 01 1b 00 ae 83 2a c1 95 44     ..Q...r.....*..D
     638:	18 22 a0 ad 18 1a 81 20 50 60 4a 14 b5 45 81 20     ."..... P`J..E. 
     648:	d5 80 b0 24 4a 5a 22 b0 14 0a 20 94 8a 80 21 68     ...$JZ"... ...!h
     658:	81 11 14 b0 55 c0 0a 84 57 63 64 55 81 bb 67 30     ....U...WcdU..g0
     668:	86 61 61 11 30 8c 8e 0c 29 11 22 50 14 44 29 4a     .aa.0...)."P.D)J
     678:	54 11 10 2c 94 05 15 11 a5 2a bb 65 10 29 41 76     T..,.....*.e.)Av
     688:	ca 2b 6d 28 bb 65 80 a2 8b b6 89 00 a2 ed 90 08     .+m(.e..........
     698:	8c 05 58 23 01 60 d1 30 8e 02 2b 05 50 14 22 40     ..X#.`.0..+.P."@
     6a8:	ac 05 04 01 54 28 d1 04 36 c2 89 59 2a 88 e7 0a     ....T(..6..Y*...
     6b8:	08 d0 40 31 85 28 05 11 1c e1 40 50 5a 53 18 52     ..@1.(....@PZS.R
     6c8:	88 08 35 ce 15 28 50 28 5d b0 8d 22 40 0a 08 82     ..5..(P(].."@...
     6d8:	01 16 15 40 bd 81 c4 e0 31 38 0b 01 60 29 64 a3     ...@....18..`)d.
     6e8:	01 6d 10 22 a2 2b 31 28 08 81 66 25 11 11 59 8a     .m.".+1(..f%..Y.
     6f8:	02 a8 0a a2 a3 55 06 80 85 04 44 29 6d 04 aa 22     .....U....D)m.."
     708:	05 28 ad a2 24 46 03 40 46 02 a8 a8 08 c0 d8 0a     .(..$F.@F.......
     718:	03 03 8a 03 0a 55 00 bc 02 29 05 40 41 82 a1 40     .....U...).@A..@
     728:	60 6a 8d 01 54 01 0a 0b 40 40 10 49 0a 25 40 10     `j..T...@@.I.%@.
     738:	60 54 55 14 55 ab 01 44 ac c2 88 08 85 db fc 54     `TU.U..D.......T
     748:	88 83 30 a0 20 80 a9 13 04 b4 10 60 68 30 16 07     ..0. ......`h0..
     758:	12 01 84 44 40 a9 88 c1 50 16 08 80 20 aa 09 41     ...D@...P... ..A
     768:	54 10 42 d2 81 50 56 41 a0 0a 08 28 52 8a 25 05     T.B..PVA...(R.%.
     778:	14 c8 83 56 83 91 50 2e cb 90 40 1d f6 c8 25 a3     ...V..P...@...%.
     788:	30 a0 84 54 10 60 ca a0 9b 02 2d 02 76 04 06 04     0..T.`....-.v...
     798:	ed 02 60 4e c0 82 a8 11 30 41 41 84 20 82 0a 08     ..`N....0AA. ...
     7a8:	44 45 05 51 50 a1 11 10 51 28 50 4a 0a 49 42 80     DE.QP...Q(PJ.IB.
     7b8:	81 12 14 89 80 20 0c 1a 24 8e 80 c5 e0 88 60 40     ..... ..$.....`@
     7c8:	60 88 e0 09 04 02 22 2e c8 aa 0a 09 b2 b0 15 52     `....."........R
     7d8:	8e d8 0a 21 45 00 d8 50 51 48 8d 5a 94 40 44 14     ...!E..PQH.Z.@D.
     7e8:	40 1a 5a 22 08 51 10 4a a2 0c 2d 04 22 e0 82 ac     @.Z".Q.J..-."...
     7f8:	15 54 be 08 94 25 02 45 58 24 44 a0 30 44 05 00     .T...%.EX$D.0D..
     808:	55 80 a5 10 50 06 02 94 42 22 30 15 28 50 04 60     U...P...B"0.(P.`
     818:	2a 52 8a 88 c0 54 42 82 23 01 51 1a 80 8c 05 45     *R...TB.#.Q....E
     828:	40 44 89 85 05 51 19 81 40 28 05 03 67 44 68 54     @D...Q..@(..gDhT
     838:	a0 4c 0b 03 41 49 81 8f 80 be 00 8b 40 62 30 45     .L..AI......@b0E
     848:	50 60 28 14 19 04 12 27 55 41 54 40 14 41 a6 ca     P`(....'UAT@.A..
     858:	25 0a 08 20 e5 12 83 01 69 b2 88 2a 2c 05 ca 2a     %.. ....i..*,..*
     868:	08 20 d3 65 10 04 aa a0 e5 1a 05 0a 0f 36 50 0a     . .e.........6P.
     878:	25 28 83 a2 25 54 01 e6 c8 08 05 a2 b3 02 03 02     %(..%T..........
     888:	52 24 04 50 aa 8a c0 98 1b 02 60 6a a0 28 aa 20     R$.P......`j.(. 
     898:	80 a3 22 80 20 25 b4 a1 6a 02 08 a5 04 04 11 42     ..". %..j......B
     8a8:	91 40 b6 95 04 40 50 26 04 44 04 76 32 20 22 2e     .@...@P&.D.v2 ".
     8b8:	d9 22 25 07 6c c0 54 08 8c 0a 22 be 89 40 55 40     ."%.l.T..."..@U@
     8c8:	10 08 98 44 80 a8 21 41 01 42 85 0a 25 28 2b 4a     ...D..!A.B..%(+J
     8d8:	02 48 94 01 42 91 71 51 01 98 d2 a2 28 24 c4 82     .H..B.qQ....($..
     8e8:	22 05 99 28 88 94 66 03 64 11 0a 55 5a aa 54 4a     "..(..f.d..UZ.TJ
     8f8:	02 a5 02 82 a5 80 d2 85 00 54 89 14 88 8b 05 60     .........T.....`
     908:	6c 7c 9e 00 89 c2 10 41 56 03 11 2b 44 14 01 d8     l|.....AV..+D...
     918:	41 04 04 01 d8 4a d1 0a aa 38 18 0b 41 04 76 02     A....J...8..A.v.
     928:	a0 94 01 1d a4 41 a3 41 04 76 12 b0 1a 82 3b 08     .....A.A.v....;.
     938:	36 b4 10 57 61 2a 08 56 82 ec 20 82 02 02 b8 55     6..Wa*.V.. ....U
     948:	08 88 08 aa 0a a0 44 40 be 8d 80 33 30 65 51 99     ......D@...30eQ.
     958:	ad c8 24 5e 88 0a c0 a8 58 0d 15 15 40 42 88 2c     ..$^....X...@B.,
     968:	09 01 41 15 0a 82 28 2a 2a 51 aa 80 2a 44 42 88     ..A...(**Q..*DB.
     978:	20 a9 11 00 a2 88 22 89 41 0a 14 a0 22 14 2b 6d      .....".A...".+m
     988:	04 04 41 0b 02 88 89 22 82 08 30 18 d0 be 55 85     ..A...."..0...U.
     998:	a1 1a 04 10 36 66 24 10 44 88 9b 64 16 a0 13 22     ....6f$.D..d..."
     9a8:	08 0b 62 41 11 28 c0 62 52 0a d1 28 11 20 50 a3     ..bA.(.bR..(. P.
     9b8:	6d 58 1a c0 90 06 b5 54 55 19 44 01 11 00 b0 14     mX.....TU.D.....
     9c8:	04 44 05 16 02 aa 44 ac 48 a2 c1 10 04 08 b8 04     .D....D.H.......
     9d8:	44 7a 22 70 44 10 88 80 a0 83 b6 54 42 a0 ed 81     Dz"pD......TB...
     9e8:	12 8d a6 d8 11 0a 83 b6 32 20 25 8b 58 1d 28 a8     ........2 %.X.(.
     9f8:	21 68 80 91 20 5b 64 60 4c 09 60 51 40 8e 23 a0     !h.. [d`L.`Q@.#.
     a08:	ed 80 40 10 15 66 10 aa 23 45 98 90 a0 80 2c c4     ..@..f..#E....,.
     a18:	82 08 84 58 a1 4a 08 30 16 ad 16 a8 a0 50 04 a0     ...X.J.0.....P..
     a28:	08 82 8a 88 2d 11 29 6c 06 85 04 4a 01 56 91 22     ....-.)l...J.V."
     a38:	26 12 0b 08 89 00 ac 82 c4 60 91 10 18 1a 94 28     &........`.....(
     a48:	45 4a 14 a2 e5 81 da 0b b2 84 48 57 61 51 04 01     EJ........HWaQ..
     a58:	db 0a 50 10 07 6c 2c 83 45 15 76 d1 10 a5 a0 bb     ..P..l,.E.v.....
     a68:	20 28 52 85 db 20 09 68 51 0c 80 20 52 82 a8 04      (R.. .hQ.. R...
     a78:	48 06 11 11 00 8e 88 c2 90 16 12 94 22 b0 15 11     H..........."...
     a88:	81 c5 04 0a d6 40 40 50 60 54 40 a2 82 a4 54 54     .....@@P`T@...TT
     a98:	14 db cc 22 2a 8a 7d f6 fb 88 a9 62 c2 d1 42 81     ..."*.}....b..B.
     aa8:	42 80 50 50 40 40 40 41 8f 80 9e 81 c5 e0 88 0c     B.PP@@@A........
     ab8:	05 22 20 c0 69 44 40 88 95 44 51 28 a0 22 94 11     ." .iD@..DQ(."..
     ac8:	28 49 68 8b 6d 11 45 40 45 00 45 10 15 22 35 14     (Ih.m.E@E.E.."5.
     ad8:	60 34 19 81 10 54 52 8c c0 a9 40 a2 03 b5 c2 82     `4...TR...@.....
     ae8:	94 41 66 02 24 04 4b 6c a0 11 10 08 88 bd 05 58     .Af.$.Kl.......X
     af8:	52 11 58 0a 82 82 03 01 42 a5 92 80 aa 0d 0a 09     R.X.....B.......
     b08:	4a 82 a8 55 1a 58 0a 82 08 81 6d 05 28 05 0a a4     J..U.X....m.(...
     b18:	44 a5 1a 82 08 0a 0a 82 b4 40 10 66 08 0a 00 ab     D........@.f....
     b28:	31 2a c0 99 81 56 0a ed 96 10 ed 98 4c 44 a8 81     1*...V......LD..
     b38:	2a c0 62 20 80 2c 06 a0 29 41 45 46 4a 51 28 22     *.b .,..)AEFJQ("
     b48:	a8 a0 54 19 81 a5 10 66 04 0a 83 30 05 a2 8e d8     ..T....f...0....
     b58:	4a 02 44 a9 41 81 20 2b 02 68 ac 0d 06 0a aa a7     J.D.A. +.h......
     b68:	8d 40 54 15 02 81 48 88 a5 a2 81 44 01 4b 68 91     .@T...H....D.Kh.
     b78:	10 11 28 a8 20 85 14 a9 50 05 03 64 8a 6c 51 91     ..(. ...P..d.lQ.
     b88:	66 14 a8 ac c0 85 15 76 50 08 c8 a9 22 b0 16 60     f......vP..."..`
     b98:	01 40 1c e4 28 a0 b3 02 24 8a 24 c0 82 0a c0 5a     .@..(...$.$....Z
     ba8:	2d 15 15 0a 00 8d 0a 52 a0 88 85 28 a2 20 a8 28     -......R...(. .(
     bb8:	22 00 a2 8a 21 44 28 20 ad 28 0a 80 21 11 81 2a     "...!D( .(..!..*
     bc8:	80 be 8c 11 30 10 04 56 60 50 2d 40 90 26 15 01     ....0..V`P-@.&..
     bd8:	15 01 26 05 45 15 04 26 04 4a 58 0a 22 a8 85 2a     ..&.E..&.JX."..*
     be8:	83 02 88 88 2a 88 a2 82 34 05 10 05 28 50 45 10     ....*...4...(PE.
     bf8:	15 12 94 01 10 11 0a 28 a2 44 44 b6 03 68 30 15     .......(.DD..h0.
     c08:	14 54 a0 c0 90 04 40 18 14 48 89 00 be 84 44 42     .T....@..H....DB
     c18:	22 11 20 10 40 55 0a 52 88 25 01 45 14 14 40 a5     ". .@U.R.%.E..@.
     c28:	80 d0 a2 2a 50 51 60 2a 09 11 22 36 88 b6 22 48     ...*PQ`*.."6.."H
     c38:	b0 14 4a 0a d5 4a 0a 25 04 05 41 50 4b 4a 20 5a     ..J..J.%..APKJ Z
     c48:	20 0c 05 01 41 00 89 ec 65 58 1b 32 b0 46 65 60      ...A...eX.2.Fe`
     c58:	91 70 ae 8b c1 19 88 08 b4 c4 02 0a 02 ec a9 40     .p.............@
     c68:	2c 05 76 c5 28 80 a0 2e d9 b1 10 04 15 40 10 1a     ,.v.(........@..
     c78:	0d 10 42 d2 94 2a 82 08 50 1a d1 68 82 a2 88 02     ..B..*..P..h....
     c88:	82 02 14 a2 91 20 10 0a 14 18 1a 80 88 0c 12 23     ..... .........#
     c98:	24 46 10 a8 66 81 2a 91 32 44 60 34 11 02 a9 51     $F..f.*.2D`4...Q
     ca8:	6b b6 44 12 ed 81 04 71 91 44 04 68 8d 0a 00 88     k.D....q.D.h....
     cb8:	44 c5 50 be 84 c4 88 cc c0 a8 0b 01 59 81 42 d5     D.P.........Y.B.
     cc8:	0a 48 b3 02 c0 ad 2a 13 02 85 14 b4 44 db 28 51     .H....*.....D.(Q
     cd8:	4a 08 4c 0a 91 11 51 74 44 0a 14 50 30 29 55 04     J.L...QtD..P0)U.
     ce8:	88 8a a0 50 18 1a 08 51 a5 2a a0 82 5b 52 80 8a     ...P...Q.*..[R..
     cf8:	a0 80 21 68 c0 e2 40 2b 08 88 80 bc 00 8c 40 58     ..!h..@+......@X
     d08:	32 80 20 8d a5 04 01 a3 50 52 44 05 14 4a 22 80     2. .....PRD..J".
     d18:	81 46 82 20 08 09 40 44 01 4a 50 14 40 10 41 42     .F. ..@D.JP.@.AB
     d28:	88 02 00 a5 a8 91 2b 40 40 46 60 42 28 39 db 0b     ......+@@F`B(9..
     d38:	04 66 00 18 23 30 00 c1 22 a0 ae 83 c4 61 2a 02     .f..#0.."....a*.
     d48:	c1 d6 02 c1 94 2d 06 0a a5 a1 46 0a 94 02 88 2a     .....-....F....*
     d58:	80 81 69 12 08 a0 a0 0b a1 16 d9 17 24 4c 50 15     ..i.........$LP.
     d68:	c9 13 c3 4a ac ce 20 11 b0 a3 09 50 58 52 a8 8d     ...J.. ....PXR..
     d78:	80 c5 20 6a b0 28 90 20 0a 52 81 22 08 a2 d6 94     .. j.(. .R."....
     d88:	b1 12 62 42 d1 50 26 24 10 14 49 89 a1 41 46 cc     ..bB.P&$..I..AF.
     d98:	45 a9 45 01 51 5a 14 88 85 0a 14 28 80 85 0a 14     E.E.QZ.....(....
     da8:	28 81 12 02 25 04 88 80 6e 82 44 e0 91 10 41 56     (...%...n.D...AV
     db8:	02 80 81 40 10 55 1b 45 14 11 60 48 82 8a a0 a9     ...@.U.E..`H....
     dc8:	5a 14 28 2e d8 01 14 10 17 6c 80 48 22 a2 bb 64     Z.(......l.H"..d
     dd8:	15 0a 14 22 a2 80 80 c1 a2 a0 ae 22 30 a4 06 14     ..."......."0...
     de8:	89 13 82 30 2b 24 48 01 28 b4 54 04 01 15 4a 01     ...0+$H.(.T...J.
     df8:	44 01 22 22 0d 22 40 aa 2d 81 28 54 28 22 8a 2c     D.""."@.-.(T(".,
     e08:	15 1d b2 44 c1 50 db 03 01 55 11 db 23 06 45 44     ...D.P...U..#.ED
     e18:	60 cc 0d 83 45 40 9b 88 8a b0 27 6c 88 2a 80 ed     `...E@....'l.*..
     e28:	95 0a 08 0c c0 a5 0a a8 b3 02 81 41 15 db 0a 52     ...........A...R
     e38:	88 8a 00 85 04 41 44 54 88 94 46 85 00 50 a4 85     .....ADT..F..P..
     e48:	00 a0 a0 25 2d 28 aa 11 20 54 11 40 15 40 15 00     ...%-(.. T.@.@..
     e58:	b9 8b 00 30 45 51 22 42 0a 89 4a 50 a2 c0 da 02     ...0EQ"B..JP....
     e68:	ad 0b 50 54 10 51 2a 80 b5 02 92 20 08 52 8a 80     ..PT.Q*.... .R..
     e78:	22 05 04 01 14 04 40 50 88 88 0c 15 01 98 d5 01     ".....@P........
     e88:	98 d8 0c 54 6d 82 aa c0 a2 a0 a0 0a 16 05 48 90     ...Tm.........H.
     e98:	0a 28 0b b6 51 b4 a5 ad 5d b2 88 04 80 81 b6 50     .(..Q...]......P
     ea8:	a8 ad a0 6d 94 a1 68 51 66 05 5b 03 89 82 11 38     ...m..hQf.[....8
     eb8:	22 a8 b8 08 a8 03 f7 7e e8 03 be fb e4 01 fb ef     "......~........
     ec8:	ba 00 ef be f9 00 7e fb ee 80 2a 02 b0 24 04 02     ......~...*..$..
     ed8:	24 44 e0 ea 52 94 a5 15 29 4a 51 46 94 a5 2a 08     $D..R...)JQF..*.
     ee8:	16 4a 02 08 44 41 05 50 15 40 ab 81 aa c2 10 58     .J..DA.P.@.....X
     ef8:	3a 02 c1 92 d1 60 6a d0 a2 80 aa 01 40 45 41 22     :....`j.....@EA"
     f08:	20 88 02 33 05 11 10 29 30 22 21 44 77 d9 11 50      ..3...)0"!Dw..P
     f18:	55 15 10 15 49 28 2d 58 0a a5 80 b0 34 14 06 07     U...I(-X....4...
     f28:	15 00 be 81 46 20 4b b0 02 03 01 5d b9 40 28 80     ....F K....].@(.
     f38:	2e df 22 34 50 07 6f 91 12 82 2a ed 90 40 11 10     .."4P.o...*..@..
     f48:	51 83 22 49 4a 2a 08 8a 25 02 80 88 08 2b 68 08     Q."IJ*..%....+h.
     f58:	88 88 02 05 01 12 22 09 52 23 02 41 a0 20 20 20     ......".R#.A.   
     f68:	82 0a 80 b0 14 10 60 48 02 82 ac 0a 24 28 23 21     ......`H....$(#!
     f78:	38 2e 24 28 37 35 4c 3b 33 3c 43 3e 33 31 39 47     8.$(75L;3<C>319G
     f88:	4b 37 47 46 45 44 2c 39 3f 35 43 41 31 2c 36 4b     K7GFED,9?5CA1,6K
     f98:	46 42 1f 48 3f 35 39 32 3c 3a 34 2e 38 38 4b ff     FB.H?592<:4.88K.

00000fa8 <spacefig_info>:
     fa8:	73 70 61 63 65 66 69 67 68 74 20 32 30 39 31 0a     spacefight 2091.
     fb8:	43 61 72 73 74 65 6e 20 53 6f 65 72 65 6e 73 65     Carsten Soerense
     fc8:	6e 0a 0a 0a 00                                      n....

00000fcd <spacefig>:
     fcd:	12 24 53 70 61 63 65 46 69 67 68 74 32 30 39 31     .$SpaceFight2091
     fdd:	20 62 79 20 53 6c 61 6d 6d 65 72 2f 41 6e 61 72      by Slammer/Anar
     fed:	63 68 79 21 00 ff 00 e0 27 86 22 2e 12 26 ac 40     chy!....'."..&.@
     ffd:	60 00 f0 55 68 00 a8 6f f8 1e f7 65 ac 57 f8 1e     `..Uh..o...e.W..
    100d:	f7 55 78 08 38 c0 12 36 ac 40 60 00 61 03 62 00     .Ux.8..6.@`.a.b.
    101d:	f2 55 22 9e ac 3f f0 65 40 00 12 60 70 ff f0 55     .U"..?.e@..`p..U
    102d:	28 3e 26 1e 25 66 24 7e 23 50 ac 48 f4 65 30 00     (>&.%f$~#P.H.e0.
    103d:	12 94 31 00 12 94 32 00 12 94 33 00 12 94 34 00     ..1...2...3...4.
    104d:	12 94 22 ea ac 40 f0 65 70 20 f0 55 40 c0 00 ee     .."..@.ep .U@...
    105d:	22 9e 12 54 ac 41 f0 65 30 00 12 54 00 ee 26 ea     "..T.A.e0..T..&.
    106d:	ac 43 60 38 61 00 62 00 f2 55 ac 46 60 00 61 00     .C`8a.b..U.F`.a.
    107d:	62 01 63 01 64 01 65 01 66 01 67 05 68 00 69 00     b.c.d.e.f.g.h.i.
    108d:	6a 00 6b 00 6c 05 fc 55 ac 3f 60 ff f0 55 00 e0     j.k.l..U.?`..U..
    109d:	26 a6 26 8c 26 be 26 6e 26 58 26 c6 65 00 15 18     &.&.&.&n&X&.e...
    10ad:	73 01 33 05 13 7e 63 00 13 7e ac 3f f0 65 80 56     s.3..~c..~.?.e.V
    10bd:	80 56 80 56 f0 55 27 78 26 a6 26 8c 26 be 26 6e     .V.V.U'x&.&.&.&n
    10cd:	60 20 61 19 a9 af 62 08 63 00 d0 18 70 08 f2 1e     ` a...b.c...p...
    10dd:	73 01 33 08 13 0a 26 64 28 36 28 36 ac 3f f0 65     s.3...&d(6(6.?.e
    10ed:	40 00 00 ee 26 64 26 6e ac 3f f0 65 70 ff f0 55     @...&d&n.?.ep..U
    10fd:	ac 42 f0 65 70 01 f0 55 26 64 26 6e 60 01 f0 18     .B.ep..U&d&n`...
    110d:	28 3e ac 3f f0 65 30 00 13 24 28 36 28 36 00 ee     (>.?.e0..$(6(6..
    111d:	ac 50 f2 65 30 00 13 a4 72 ff f2 55 32 00 00 ee     .P.e0...r..U2...
    112d:	ac 40 f0 65 62 c0 82 05 82 56 82 56 82 56 82 56     .@.eb....V.V.V.V
    113d:	82 56 80 20 ac 52 f0 55 c3 03 c4 01 83 44 ac 48     .V. .R.U.....D.H
    114d:	f3 1e f0 65 40 00 12 e0 a8 6a f3 1e f0 65 83 00     ...e@....j...e..
    115d:	ac 46 f1 65 80 34 70 07 71 19 ac 50 f2 55 60 02     .F.e.4p.q..P.U`.
    116d:	f0 18 14 74 24 74 71 04 ac 50 f1 55 24 74 41 40     ...t$tq..P.U$tA@
    117d:	14 4e 41 3f 14 4e 41 3e 14 4e 41 3d 14 4e 41 2b     .NA?.NA>.NA=.NA+
    118d:	14 0e 41 2a 14 0e 41 29 14 0e 41 28 14 0e 41 27     ..A*..A)..A(..A'
    119d:	14 0e 4f 00 00 ee 82 00 83 10 ac 44 f1 65 40 00     ..O........D.e@.
    11ad:	13 fe 50 20 13 fe ac 42 f0 65 70 01 f0 55 60 01     ..P ...B.ep..U`.
    11bd:	f0 18 25 e6 ac 44 60 00 61 00 f1 55 14 4e 6a 00     ..%..D`.a..U.Nj.
    11cd:	24 5e 24 5a 7a 01 3a 05 14 00 24 5e 14 4e 82 00     $^$Zz.:...$^.N..
    11dd:	83 00 82 56 82 56 82 56 ac 40 f0 65 ac 57 f0 1e     ...V.V.V.@.e.W..
    11ed:	f2 1e f0 65 40 00 00 ee f0 65 70 ff 82 00 60 00     ...e@....ep...`.
    11fd:	f0 55 42 00 14 44 80 20 f0 55 62 10 f2 1e 60 00     .UB..D. .Ub...`.
    120d:	f0 55 14 4e 60 f8 80 32 61 2c ac 3a d0 14 24 74     .U.N`..2a,.:..$t
    121d:	ac 50 60 00 61 00 f1 55 00 ee 69 01 14 62 69 ff     .P`.a..U..i..bi.
    122d:	14 62 26 8c 60 01 f0 18 ac 41 f0 65 80 94 f0 55     .b&.`....A.e...U
    123d:	26 8c 18 3a ac 50 f1 65 aa f6 d0 13 00 ee ac 4d     &..:.P.e.......M
    124d:	f0 65 70 ff f0 55 30 00 00 ee 60 05 f0 55 65 00     .ep..U0...`..Ue.
    125d:	25 18 24 98 65 01 15 18 ac 4e f1 65 40 00 15 04     %.$.e....N.e@...
    126d:	40 01 14 cc 40 02 14 f0 60 0a f0 18 ac 47 f0 65     @...@...`....G.e
    127d:	30 0c 70 01 f0 55 71 01 ac 4f 80 10 f0 55 31 04     0.p..Uq..O...U1.
    128d:	00 ee ac 4e 60 00 61 00 f1 55 00 ee 60 0a f0 18     ...N`.a..U..`...
    129d:	ac 47 f0 65 30 0c 70 01 f0 55 71 01 ac 4f 80 10     .G.e0.p..Uq..O..
    12ad:	f0 55 31 04 00 ee ac 4e 60 02 61 00 f1 55 00 ee     .U1....N`.a..U..
    12bd:	ac 46 f0 65 70 fc f0 55 30 00 00 ee ac 4e 60 03     .F.ep..U0....N`.
    12cd:	f0 55 00 ee ac 46 f0 65 70 04 f0 55 30 28 00 ee     .U...F.ep..U0(..
    12dd:	ac 4e 60 01 f0 55 00 ee ac 46 f1 65 87 10 86 00     .N`..U...F.e....
    12ed:	77 09 68 00 ac 40 f0 65 89 00 ac 48 f8 1e f0 65     w.h..@.e...H...e
    12fd:	aa 0f f9 1e 30 00 d6 70 3f 00 25 46 76 12 78 01     ....0..p?.%Fv.x.
    130d:	38 05 15 2a 00 ee 45 00 00 ee d6 70 ac 48 f8 1e     8..*..E....p.H..
    131d:	60 00 f0 55 26 6e ac 42 f0 65 70 02 f0 55 26 6e     `..U&n.B.ep..U&n
    132d:	25 e6 ac 44 16 16 ac 44 f1 65 40 00 00 ee 41 2c     %..D...D.e@...A,
    133d:	15 7e 41 2d 15 7e 41 2e 15 7e 31 2f 00 ee 82 00     .~A-.~A..~1/....
    134d:	83 00 82 56 82 56 82 56 ac 40 f0 65 ac 57 f0 1e     ...V.V.V.@.e.W..
    135d:	f2 1e f0 65 40 00 00 ee f0 65 70 ff 82 00 60 00     ...e@....ep...`.
    136d:	f0 55 42 00 15 b4 80 20 f0 55 62 10 f2 1e 60 00     .UB.... .Ub...`.
    137d:	f0 55 15 be 60 f8 80 32 61 2c ac 3a d0 14 25 e6     .U..`..2a,.:..%.
    138d:	ac 44 16 16 60 0a e0 9e 00 ee ac 44 f0 65 30 00     .D..`......D.e0.
    139d:	00 ee ac 43 f0 65 70 07 ac 44 61 2e f1 55 25 e6     ...C.ep..Da..U%.
    13ad:	60 01 f0 18 00 ee ac 44 f1 65 aa f6 30 00 d0 13     `......D.e..0...
    13bd:	00 ee 25 e6 ac 44 f1 65 71 fe 41 08 16 16 41 09     ..%..D.eq.A...A.
    13cd:	16 16 f1 55 25 e6 30 00 4f 00 00 ee 65 00 25 18     ...U%.0.O...e.%.
    13dd:	65 01 25 18 00 ee 60 00 61 00 f1 55 00 ee 25 c4     e.%...`.a..U..%.
    13ed:	25 f2 60 03 e0 a1 16 44 60 0c e0 a1 16 30 00 ee     %.`....D`....0..
    13fd:	ac 43 f0 65 40 70 00 ee 26 58 70 01 ac 43 f0 55     .C.e@p..&Xp..C.U
    140d:	26 58 00 ee ac 43 f0 65 40 00 00 ee 26 58 70 ff     &X...C.e@...&Xp.
    141d:	ac 43 f0 55 26 58 00 ee ac 43 f0 65 61 31 aa cf     .C.U&X...C.ea1..
    142d:	d0 10 00 ee ac 3f f0 65 63 39 64 22 16 76 ac 42     .....?.ec9d".v.B
    143d:	f0 65 63 22 64 03 ac 53 f0 33 f2 65 f0 29 26 86     .ec"d..S.3.e.)&.
    144d:	f1 29 26 86 f2 29 d3 45 73 05 00 ee ac 41 f0 65     .)&..).Es....A.e
    145d:	40 00 00 ee 61 4d 62 01 aa ef d1 27 71 08 70 ff     @...aMb....'q.p.
    146d:	30 00 16 9a 00 ee 60 65 61 00 ab 19 62 08 63 00     0.....`ea...b.c.
    147d:	d0 18 70 08 f2 1e 73 01 33 04 16 b0 00 ee 60 00     ..p...s.3.....`.
    148d:	61 00 aa f9 16 ac 61 00 62 2c 63 00 ac 40 f0 65     a.....a.b,c..@.e
    149d:	84 00 ac 67 f4 1e f3 1e f0 65 ac 3a 30 00 d1 24     ...g.....e.:0..$
    14ad:	71 08 73 01 33 10 16 d2 00 ee 27 5c 27 14 27 2c     q.s.3.....'\'.',
    14bd:	26 f6 27 6a 00 ee 27 0e 28 36 27 0e 28 3a 27 0e     &.'j..'.(6'.(:'.
    14cd:	28 3a 27 0e 28 36 27 0e 28 36 27 0e 18 36 60 03     (:'.(6'.(6'..6`.
    14dd:	f0 18 00 ee 60 20 61 0c ab f9 62 08 63 00 d0 18     ....` a...b.c...
    14ed:	70 08 f2 1e 73 01 33 08 17 1e 00 ee 60 30 61 20     p...s.3.....`0a 
    14fd:	a9 ef 62 08 63 00 d0 18 70 08 f2 1e 73 01 33 04     ..b.c...p...s.3.
    150d:	17 36 ac 40 f0 65 80 56 80 56 80 56 80 56 80 56     .6.@.e.V.V.V.V.V
    151d:	70 01 f0 30 60 3b 61 29 d0 1a 00 ee 61 00 28 3e     p..0`;a)....a.(>
    152d:	00 fc 71 01 31 20 17 5e 00 ee 61 00 28 3e 00 fb     ..q.1 .^..a.(>..
    153d:	71 01 31 20 17 6c 00 ee 61 00 28 3e 00 c4 71 01     q.1 .l..a.(>..q.
    154d:	31 10 17 7a 00 ee ac 3e 60 64 f0 55 27 d0 26 a6     1..z...>`d.U'.&.
    155d:	26 8c 26 be 26 6e 27 e8 28 3e 28 00 27 a6 60 0a     &.&.&n'.(>(.'.`.
    156d:	e0 9e 17 98 00 ee ac 3e f0 65 70 ff f0 55 30 00     .......>.ep..U0.
    157d:	00 ee 60 64 f0 55 27 d0 ab 39 60 10 61 18 62 20     ..`d.U'..9`.a.b 
    158d:	63 00 d0 10 70 10 f2 1e 73 01 33 06 17 c2 00 ee     c...p...s.3.....
    159d:	a9 2f 60 20 61 18 62 20 63 00 d0 10 70 10 f2 1e     ./` a.b c...p...
    15ad:	73 01 33 04 17 da 00 ee ac 56 60 00 f0 55 82 00     s.3......V`..U..
    15bd:	64 00 28 28 72 01 80 20 74 01 34 10 17 f2 00 ee     d.((r.. t.4.....
    15cd:	ac 56 f0 65 82 00 84 00 28 28 a8 4a 82 5e f2 1e     .V.e....((.J.^..
    15dd:	c0 7f c1 3f f1 55 ac 39 d0 11 63 0f 74 01 84 32     ...?.U.9..c.t..2
    15ed:	80 40 ac 56 f0 55 00 ee a8 4a 80 5e f0 1e f1 65     .@.V.U...J.^...e
    15fd:	ac 39 d0 11 00 ee 60 0c 18 40 60 06 18 40 60 01     .9....`..@`..@`.
    160d:	f0 15 f0 07 30 00 18 42 00 ee 0a 11 5b 22 5b 29     ....0..B....["[)
    161d:	75 38 54 11 0c 09 34 13 78 34 26 04 06 1a 0c 22     u8T...4.x4&...."
    162d:	20 0a 00 16 06 05 3f 07 00 1e 00 12 24 36 48 00      .....?.....$6H.
	...
    1661:	00 01 01 01 01 00 00 00 00 00 00 00 00 00 00 00     ................
    1671:	00 01 01 01 01 00 00 00 00 00 00 00 00 00 02 02     ................
    1681:	02 00 00 00 00 01 01 01 00 00 00 00 00 00 01 01     ................
    1691:	01 00 00 00 00 01 01 01 00 00 00 00 05 05 00 00     ................
    16a1:	00 05 00 00 05 00 00 00 05 05 00 00 01 01 00 00     ................
    16b1:	00 01 00 00 01 00 00 00 01 01 00 0a 0a 00 00 0a     ................
    16c1:	0a 00 00 00 00 0a 0a 00 00 0a 0a 01 01 00 00 01     ................
    16d1:	01 00 00 00 00 01 01 00 00 01 01 14 14 14 14 14     ................
    16e1:	14 14 14 14 14 14 14 14 14 14 14 01 01 01 01 01     ................
    16f1:	01 01 01 01 01 01 01 01 01 01 01 3c 00 7c 00 e0     ...........<.|..
    1701:	00 c0 00 cc 71 cc fb cd db cd 9b cd 9b fd fb 7c     ....q..........|
    1711:	fb 00 00 00 00 00 00 ff ff ff ff 00 00 00 00 00     ................
    1721:	00 00 00 f0 e0 f9 f0 7d 98 6d f8 6d 80 6d f8 6c     .......}.m.m.m.l
    1731:	f8 00 00 00 00 00 00 ff ff ff ff 38 00 7c 00 ec     ...........8.|..
    1741:	00 cc 00 cd 99 cd 9b cd 9b cd 9b cd 9b fc f3 78     ...............x
    1751:	61 00 00 00 00 00 00 ff ff ff ff 00 07 00 07 00     a...............
    1761:	06 00 06 c1 cc e3 cc 37 08 f6 08 06 00 f6 18 f6     .......7........
    1771:	18 00 00 00 00 00 00 ff ff ff ff fd fd 11 31 31     ..............11
    1781:	31 31 31 a1 b3 bf bf b3 b3 b3 b3 1c 3c 70 60 78     111.........<p`x
    1791:	60 7c 3c 0e 1f 1b 19 1f 19 1f 1f 0e 1f bb b3 33     `|<............3
    17a1:	b3 bf 1e 66 76 7e 6e 66 66 66 66 cc cc cd cd cc     ...fv~nffff.....
    17b1:	ec 7d 3d 70 f3 83 e0 f0 33 f3 e0 c0 c1 c3 c3 c3     .}=p....3.......
    17c1:	e3 7b 39 ec ec 8c 0c cc 0f e7 e3 c7 cf dc d8 de     .{9.............
    17d1:	d8 9f 0f 60 60 60 60 60 70 3c 1c 00 00 97 d2 03     ...`````p<......
    17e1:	80 01 00 0f e0 3f f8 55 54 ab ba ff 6e ba ba 55     .....?.UT...n..U
    17f1:	54 3f f8 4f e4 00 00 80 02 00 00 03 c0 06 60 04     T?.O..........`.
    1801:	a0 03 c0 04 20 0b 30 14 58 14 28 10 58 12 a8 0d     .... .0.X.(.X...
    1811:	50 16 a8 23 c4 7f fe 40 02 00 00 4a aa 15 50 4a     P..#...@...J..PJ
    1821:	aa d5 53 e4 27 7f fe 39 9c 0c 30 06 60 07 e0 33     ..S.'..9..0.`..3
    1831:	cc 2b d4 07 e0 03 c0 01 80 00 00 03 c0 05 60 06     .+............`.
    1841:	a0 03 c0 1b d8 2d 74 5e ba a5 65 c6 a3 c7 e3 cd     .....-t^..e.....
    1851:	b3 da 5b 54 2a 18 18 18 18 30 0c 30 0c 48 12 a4     ..[T*....0.0.H..
    1861:	25 84 21 4c 32 32 4c 02 40 1f f8 20 ac 28 54 20     %.!L22L.@.. .(T 
    1871:	ac 1f f8 7f fe 92 49 92 49 92 49 3f fc 40 02 5a     ......I.I.I?.@.Z
    1881:	fa 50 0a 43 ea 52 4a 47 ca 50 0a 5f fa 40 02 3f     .P.C.RJG.P._.@.?
    1891:	fc 0f f0 38 1c 54 36 ac 2b f8 1f 01 00 01 00 01     ...8.T6.+.......
    18a1:	00 01 00 01 00 03 80 03 80 03 80 07 c0 c6 c6 7d     ...............}
    18b1:	7c 3f f8 7f fc c3 86 01 00 00 00 10 10 10 28 7c     |?............(|
    18c1:	d6 fe 80 80 80 38 79 c3 f3 7b 1b fb f1 e3 e7 8e     .....8y..{......
    18d1:	0c 0c 0c ef e7 8e df db d9 df df db 99 0e 1e b8     ................
    18e1:	b0 bc 30 be 9e c3 c3 c3 c3 c3 e3 7b 3b 66 66 66     ..0........{;fff
    18f1:	66 66 7e 3c 18 38 79 e3 c3 f1 c0 fb 7b e0 e0 00     ff~<.8y.....{...
    1901:	c0 e0 60 e0 c0 3c 00 7c 00 e0 00 c0 00 f1 e0 79     ..`..<.|.......y
    1911:	f1 1d bb 0d 9b 0d 9b fd fb f9 f1 01 80 01 80 01     ................
    1921:	80 fc 3f ff ff 00 00 00 00 00 00 00 00 e1 ce f3     ..?.............
    1931:	df b7 19 36 1f 36 18 f7 df f3 cf 00 00 00 00 00     ...6.6..........
    1941:	00 ff ff ff ff 0f 00 1f 00 38 00 30 00 3e c7 3e     .........8.0.>.>
    1951:	cf b0 1d b0 d9 30 d9 b0 df b0 cf 00 01 00 0f 00     .....0..........
    1961:	0f ff e0 ff ff 30 60 30 60 30 60 30 60 3c 78 be     .....0`0`0`0`<x.
    1971:	78 b7 60 b3 60 b3 70 b3 3c b3 1c 80 00 80 00 00     x.`.`.p.<.......
    1981:	00 7f ff ff ff 3c 3c 7e 7e e6 e6 c6 c6 0e c6 1c     .....<<~~.......
    1991:	c6 38 c6 70 c6 e0 c6 fe fe fe 7c 00 00 00 00 00     .8.p......|.....
    19a1:	00 ff ff ff ff 3c c7 7e c7 e6 c6 c6 c6 c6 cc fe     .....<.~........
    19b1:	cc 7e c8 06 c8 06 c0 fe d8 fc d8 00 00 00 00 00     .~..............
    19c1:	00 ff ff ff ff 3c 7c e1 c1 cd cd fd 7c 77 f7 c0     .....<|.....|w..
    19d1:	81 e1 81 f1 f1 e0 e0 80 80 80 80 80 80 f0 f8 dd     ................
    19e1:	cd fd f9 dd cc 71 f3 c7 86 e7 86 f6 f6 c7 ef 6d     .....q.........m
    19f1:	6c ec 6c 6f 6f 19 99 d9 df cf c6 c6 86 98 98 98     l.loo...........
    1a01:	98 18 00 18 18 80 ff aa 55 ff 00 00 00 00 00 00     ........U.......
	...
    1ae1:	00 00 00 ff                                         ....

00001ae5 <font_6x8>:
	...
    1aed:	20 20 20 20 20 00 20 00 50 50 50 00 00 00 00 00          . .PPP.....
    1afd:	50 50 f8 50 f8 50 50 00 20 78 a0 70 28 f0 20 00     PP.P.PP. x.p(. .
    1b0d:	c0 c8 10 20 40 98 18 00 60 90 a0 40 a8 90 68 00     ... @...`..@..h.
    1b1d:	60 20 40 00 00 00 00 00 10 20 40 40 40 20 10 00     ` @...... @@@ ..
    1b2d:	40 20 10 10 10 20 40 00 00 20 a8 70 a8 20 00 00     @ ... @.. .p. ..
    1b3d:	00 20 20 f8 20 20 00 00 00 00 00 00 60 20 40 00     .  .  ......` @.
    1b4d:	00 00 00 f0 00 00 00 00 00 00 00 00 00 60 60 00     .............``.
    1b5d:	00 08 10 20 40 80 00 00 70 88 98 a8 c8 88 70 00     ... @...p.....p.
    1b6d:	20 60 20 20 20 20 f8 00 70 88 10 20 40 80 f8 00      `    ..p.. @...
    1b7d:	f0 08 08 f0 08 08 f0 00 10 30 50 90 f8 10 10 00     .........0P.....
    1b8d:	f8 80 80 f0 08 08 f0 00 30 40 80 f0 88 88 70 00     ........0@....p.
    1b9d:	f8 08 10 20 40 40 40 00 70 88 88 70 88 88 70 00     ... @@@.p..p..p.
    1bad:	70 88 88 70 08 08 70 00 00 60 60 00 60 60 00 00     p..p..p..``.``..
    1bbd:	00 60 60 00 60 20 40 00 10 20 40 80 40 20 10 00     .``.` @.. @.@ ..
    1bcd:	00 00 f8 00 f8 00 00 00 40 20 10 08 10 20 40 00     ........@ ... @.
    1bdd:	70 88 08 10 20 00 20 00 70 88 08 68 a8 a8 70 00     p... . .p..h..p.
    1bed:	70 88 88 f8 88 88 88 00 f0 88 88 f0 88 88 f0 00     p...............
    1bfd:	78 80 80 80 80 80 78 00 f0 88 88 88 88 88 f0 00     x.....x.........
    1c0d:	f8 80 80 f8 80 80 f8 00 f8 80 80 f8 80 80 80 00     ................
    1c1d:	78 80 80 b0 88 88 70 00 88 88 88 f8 88 88 88 00     x.....p.........
    1c2d:	70 20 20 20 20 20 70 00 78 08 08 08 08 90 60 00     p     p.x.....`.
    1c3d:	88 90 a0 c0 a0 90 88 00 80 80 80 80 80 80 f8 00     ................
    1c4d:	88 d8 a8 88 88 88 88 00 88 88 c8 a8 98 88 88 00     ................
    1c5d:	70 88 88 88 88 88 70 00 f0 88 88 f0 80 80 80 00     p.....p.........
    1c6d:	70 88 88 88 a8 98 78 00 f0 88 88 f0 a0 90 88 00     p.....x.........
    1c7d:	78 80 80 70 08 08 f0 00 f8 20 20 20 20 20 20 00     x..p.....      .
    1c8d:	88 88 88 88 88 88 70 00 88 88 88 88 88 50 20 00     ......p......P .
    1c9d:	88 88 88 a8 a8 d8 88 00 88 88 50 20 50 88 88 00     ..........P P...
    1cad:	88 88 88 50 20 20 20 00 f8 10 20 40 80 80 f8 00     ...P   ... @....
    1cbd:	60 40 40 40 40 40 60 00 00 80 40 20 10 08 00 00     `@@@@@`...@ ....
    1ccd:	18 08 08 08 08 08 18 00 20 50 88 00 00 00 00 00     ........ P......
    1cdd:	00 00 00 00 00 00 f8 00 40 20 10 00 00 00 00 00     ........@ ......
    1ced:	00 00 70 08 78 88 78 00 80 80 80 b0 c8 88 f0 00     ..p.x.x.........
    1cfd:	00 00 70 80 80 88 70 00 08 08 08 68 98 88 78 00     ..p...p....h..x.
    1d0d:	00 00 70 88 f8 80 70 00 30 48 40 e0 40 40 40 00     ..p...p.0H@.@@@.
    1d1d:	00 00 78 88 88 78 08 70 80 80 b0 c8 88 88 88 00     ..x..x.p........
    1d2d:	00 20 00 20 20 20 20 00 10 00 30 10 10 90 60 00     . .    ...0...`.
    1d3d:	80 80 90 a0 c0 a0 90 00 60 20 20 20 20 20 70 00     ........`     p.
    1d4d:	00 00 d0 a8 a8 88 88 00 00 00 b0 c8 88 88 88 00     ................
    1d5d:	00 00 70 88 88 88 70 00 00 00 f0 88 88 f0 80 80     ..p...p.........
    1d6d:	00 00 68 90 90 b0 50 18 00 00 b0 c8 80 80 80 00     ..h...P.........
    1d7d:	00 00 70 80 70 08 f0 00 40 40 e0 40 40 48 30 00     ..p.p...@@.@@H0.
    1d8d:	00 00 88 88 88 98 68 00 00 00 88 88 88 50 20 00     ......h......P .
    1d9d:	00 00 88 88 a8 a8 50 00 00 00 88 50 20 50 88 00     ......P....P P..
    1dad:	00 00 88 88 88 78 08 70 00 00 f8 10 20 40 f8 00     .....x.p.... @..
    1dbd:	20 40 40 80 40 40 20 00 20 20 20 20 20 20 20 00      @@.@@ .       .
    1dcd:	40 20 20 10 20 20 40 00 00 00 40 a8 10 00 00 00     @  .  @...@.....
    1ddd:	fc fc fc fc fc fc fc fc 40 20 10 f8 10 20 40 00     ........@ ... @.
    1ded:	10 20 40 f8 40 20 10 00 20 70 a8 20 20 20 00 00     . @.@ .. p.   ..
    1dfd:	00 20 20 20 a8 70 20 00 00 70 f8 f8 f8 70 00 00     .   .p ..p...p..

00001e0d <font_hex_8x10>:
    1e0d:	7c 82 86 8a 92 a2 c2 82 7c 00 08 18 28 08 08 08     |.......|...(...
    1e1d:	08 08 3e 00 38 44 82 04 08 10 20 40 fe 00 38 44     ..>.8D.... @..8D
    1e2d:	82 02 3c 02 82 44 38 00 84 84 84 84 7e 04 04 04     ..<..D8.....~...
    1e3d:	04 00 7e 80 80 80 7c 02 02 02 fe 00 78 84 80 80     ..~...|.....x...
    1e4d:	fc 82 82 82 7c 00 7e 82 04 08 08 08 08 08 08 00     ....|.~.........
    1e5d:	38 44 82 82 7c 82 82 44 38 00 38 44 82 82 46 3a     8D..|..D8.8D..F:
    1e6d:	02 04 38 00 38 44 82 82 fe 82 82 82 82 00 fc 82     ..8.8D..........
    1e7d:	82 82 fc 82 82 82 fc 00 3e 40 80 80 80 80 80 40     ........>@.....@
    1e8d:	3e 00 f8 84 82 82 82 82 82 84 f8 00 fe 80 80 80     >...............
    1e9d:	fe 80 80 80 fe 00 fe 80 80 80 fe 80 80 80 80 00     ................

00001ead <font_hex_4x6>:
    1ead:	e0 a0 a0 a0 e0 00 c0 40 40 40 e0 00 e0 20 e0 80     .......@@@... ..
    1ebd:	e0 00 e0 20 e0 20 e0 00 a0 a0 e0 20 20 00 e0 80     ... . .....  ...
    1ecd:	e0 20 e0 00 80 80 e0 a0 e0 00 e0 20 20 20 20 00     . .........    .
    1edd:	e0 a0 e0 a0 e0 00 e0 a0 e0 20 20 00 e0 a0 e0 a0     .........  .....
    1eed:	a0 00 c0 a0 c0 a0 c0 00 e0 80 80 80 e0 00 c0 a0     ................
    1efd:	a0 a0 c0 00 e0 80 e0 80 e0 00 e0 80 e0 80 80 00     ................
	...

00001f0e <__ctors_end>:
    1f0e:	11 24       	eor	r1, r1
    1f10:	1f be       	out	0x3f, r1	; 63
    1f12:	cf ef       	ldi	r28, 0xFF	; 255
    1f14:	d8 e0       	ldi	r29, 0x08	; 8
    1f16:	de bf       	out	0x3e, r29	; 62
    1f18:	cd bf       	out	0x3d, r28	; 61

00001f1a <__do_copy_data>:
    1f1a:	11 e0       	ldi	r17, 0x01	; 1
    1f1c:	a0 e0       	ldi	r26, 0x00	; 0
    1f1e:	b1 e0       	ldi	r27, 0x01	; 1
    1f20:	e0 e2       	ldi	r30, 0x20	; 32
    1f22:	f7 e3       	ldi	r31, 0x37	; 55
    1f24:	02 c0       	rjmp	.+4      	; 0x1f2a <__do_copy_data+0x10>
    1f26:	05 90       	lpm	r0, Z+
    1f28:	0d 92       	st	X+, r0
    1f2a:	a2 31       	cpi	r26, 0x12	; 18
    1f2c:	b1 07       	cpc	r27, r17
    1f2e:	d9 f7       	brne	.-10     	; 0x1f26 <__do_copy_data+0xc>

00001f30 <__do_clear_bss>:
    1f30:	25 e0       	ldi	r18, 0x05	; 5
    1f32:	a2 e1       	ldi	r26, 0x12	; 18
    1f34:	b1 e0       	ldi	r27, 0x01	; 1
    1f36:	01 c0       	rjmp	.+2      	; 0x1f3a <.do_clear_bss_start>

00001f38 <.do_clear_bss_loop>:
    1f38:	1d 92       	st	X+, r1

00001f3a <.do_clear_bss_start>:
    1f3a:	a2 3a       	cpi	r26, 0xA2	; 162
    1f3c:	b2 07       	cpc	r27, r18
    1f3e:	e1 f7       	brne	.-8      	; 0x1f38 <.do_clear_bss_loop>
    1f40:	0e 94 c9 14 	call	0x2992	; 0x2992 <main>
    1f44:	0c 94 8e 1b 	jmp	0x371c	; 0x371c <_exit>

00001f48 <__bad_interrupt>:
    1f48:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001f4c <group0>:
vm_state_t vms;

// stockage temporaire sprite
static uint8_t block[32];

uint8_t group0(uint8_t b1, uint8_t b2){
    1f4c:	cf 93       	push	r28
	if ((b1&0xf)!=0) return CHIP_BAD_OPCODE; // system call not used
    1f4e:	c8 2f       	mov	r28, r24
    1f50:	cf 70       	andi	r28, 0x0F	; 15
    1f52:	61 f4       	brne	.+24     	; 0x1f6c <group0+0x20>
	if ((b2&0xf0)==0xc0){ // 00CN, (mode schip seulement) glisse l'affichage N lignes vers le bas  
    1f54:	86 2f       	mov	r24, r22
    1f56:	80 7f       	andi	r24, 0xF0	; 240
    1f58:	80 3c       	cpi	r24, 0xC0	; 192
    1f5a:	59 f1       	breq	.+86     	; 0x1fb2 <group0+0x66>
		scroll_down(b2&0xf);	
	}else{
		switch (b2){
    1f5c:	6b 3f       	cpi	r22, 0xFB	; 251
    1f5e:	69 f0       	breq	.+26     	; 0x1f7a <group0+0x2e>
    1f60:	78 f0       	brcs	.+30     	; 0x1f80 <group0+0x34>
    1f62:	6c 3f       	cpi	r22, 0xFC	; 252
    1f64:	39 f0       	breq	.+14     	; 0x1f74 <group0+0x28>
		default:
			return CHIP_BAD_OPCODE;
		}//switch
	}
	return 0;
}
    1f66:	8c 2f       	mov	r24, r28
    1f68:	cf 91       	pop	r28
    1f6a:	08 95       	ret
		case 0xFE: //00FE, (mode schip seulement) revient au vms.mode par dfaut chip-8 rsolution 64x32
			break; // ignore
		case 0xFF:  //00FF, (mode schip seulement) passe en vms.mode schip rsolution 128x64
			break; // ignore est toujours en mode SCHIP
		default:
			return CHIP_BAD_OPCODE;
    1f6c:	c1 e0       	ldi	r28, 0x01	; 1
		}//switch
	}
	return 0;
}
    1f6e:	8c 2f       	mov	r24, r28
    1f70:	cf 91       	pop	r28
    1f72:	08 95       	ret
			break;
		case 0xFB: // 00FB, (mode schip seulement) glisse l'affichage vers la droite de 4 pixels
			chip_scroll_right();
			break;
		case 0xFC: // 00FC, (mode schip seulement) glisse l'affichage vers la gauche de 4 pixels
			chip_scroll_left();
    1f74:	0e 94 d2 19 	call	0x33a4	; 0x33a4 <chip_scroll_left>
			break;
    1f78:	f6 cf       	rjmp	.-20     	; 0x1f66 <group0+0x1a>
			break;
		case 0xEE: // 00EE, sortie de sous-routine
			vms.pc=vms.stack[vms.sp--];
			break;
		case 0xFB: // 00FB, (mode schip seulement) glisse l'affichage vers la droite de 4 pixels
			chip_scroll_right();
    1f7a:	0e 94 ab 19 	call	0x3356	; 0x3356 <chip_scroll_right>
			break;
    1f7e:	f3 cf       	rjmp	.-26     	; 0x1f66 <group0+0x1a>
uint8_t group0(uint8_t b1, uint8_t b2){
	if ((b1&0xf)!=0) return CHIP_BAD_OPCODE; // system call not used
	if ((b2&0xf0)==0xc0){ // 00CN, (mode schip seulement) glisse l'affichage N lignes vers le bas  
		scroll_down(b2&0xf);	
	}else{
		switch (b2){
    1f80:	60 3e       	cpi	r22, 0xE0	; 224
    1f82:	a1 f0       	breq	.+40     	; 0x1fac <group0+0x60>
    1f84:	6e 3e       	cpi	r22, 0xEE	; 238
    1f86:	91 f7       	brne	.-28     	; 0x1f6c <group0+0x20>
		case 0xE0:  // 00E0, efface l'cran
			cls();
			break;
		case 0xEE: // 00EE, sortie de sous-routine
			vms.pc=vms.stack[vms.sp--];
    1f88:	e0 91 3e 05 	lds	r30, 0x053E
    1f8c:	8f ef       	ldi	r24, 0xFF	; 255
    1f8e:	8e 0f       	add	r24, r30
    1f90:	80 93 3e 05 	sts	0x053E, r24
    1f94:	f0 e0       	ldi	r31, 0x00	; 0
    1f96:	ee 0f       	add	r30, r30
    1f98:	ff 1f       	adc	r31, r31
    1f9a:	e6 5c       	subi	r30, 0xC6	; 198
    1f9c:	fa 4f       	sbci	r31, 0xFA	; 250
    1f9e:	27 a1       	ldd	r18, Z+39	; 0x27
    1fa0:	30 a5       	ldd	r19, Z+40	; 0x28
    1fa2:	30 93 3b 05 	sts	0x053B, r19
    1fa6:	20 93 3a 05 	sts	0x053A, r18
			break;
    1faa:	dd cf       	rjmp	.-70     	; 0x1f66 <group0+0x1a>
	if ((b2&0xf0)==0xc0){ // 00CN, (mode schip seulement) glisse l'affichage N lignes vers le bas  
		scroll_down(b2&0xf);	
	}else{
		switch (b2){
		case 0xE0:  // 00E0, efface l'cran
			cls();
    1fac:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
			break;
    1fb0:	da cf       	rjmp	.-76     	; 0x1f66 <group0+0x1a>
static uint8_t block[32];

uint8_t group0(uint8_t b1, uint8_t b2){
	if ((b1&0xf)!=0) return CHIP_BAD_OPCODE; // system call not used
	if ((b2&0xf0)==0xc0){ // 00CN, (mode schip seulement) glisse l'affichage N lignes vers le bas  
		scroll_down(b2&0xf);	
    1fb2:	86 2f       	mov	r24, r22
    1fb4:	8f 70       	andi	r24, 0x0F	; 15
    1fb6:	0e 94 4a 19 	call	0x3294	; 0x3294 <scroll_down>
    1fba:	d5 cf       	rjmp	.-86     	; 0x1f66 <group0+0x1a>

00001fbc <group8>:
}

uint8_t group8(uint8_t b1, uint8_t b2){
	uint8_t x, y;
	
	x=rx(b1);
    1fbc:	28 2f       	mov	r18, r24
    1fbe:	2f 70       	andi	r18, 0x0F	; 15
	y=ry(b2);
    1fc0:	a6 2f       	mov	r26, r22
    1fc2:	a2 95       	swap	r26
    1fc4:	af 70       	andi	r26, 0x0F	; 15
	switch(b2&0xf){
    1fc6:	86 2f       	mov	r24, r22
    1fc8:	8f 70       	andi	r24, 0x0F	; 15
    1fca:	48 2f       	mov	r20, r24
    1fcc:	50 e0       	ldi	r21, 0x00	; 0
    1fce:	4f 30       	cpi	r20, 0x0F	; 15
    1fd0:	51 05       	cpc	r21, r1
    1fd2:	10 f0       	brcs	.+4      	; 0x1fd8 <group8+0x1c>
	case 0xe: // 8XYE     VX := VX shl 1, VF := carry
		vms.var[15]=(vms.var[x]&128)>>7;
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
    1fd4:	81 e0       	ldi	r24, 0x01	; 1
	}//switch
	return 0;
}
    1fd6:	08 95       	ret
uint8_t group8(uint8_t b1, uint8_t b2){
	uint8_t x, y;
	
	x=rx(b1);
	y=ry(b2);
	switch(b2&0xf){
    1fd8:	4c 5c       	subi	r20, 0xCC	; 204
    1fda:	5f 4f       	sbci	r21, 0xFF	; 255
    1fdc:	fa 01       	movw	r30, r20
    1fde:	0c 94 e6 1a 	jmp	0x35cc	; 0x35cc <__tablejump2__>
		vms.var[15]=1;
		if (vms.var[y]<vms.var[x])vms.var[15]=0;		
		vms.var[x]=vms.var[y]-vms.var[x];
		break;
	case 0xe: // 8XYE     VX := VX shl 1, VF := carry
		vms.var[15]=(vms.var[x]&128)>>7;
    1fe2:	e2 2f       	mov	r30, r18
    1fe4:	f0 e0       	ldi	r31, 0x00	; 0
    1fe6:	e6 5c       	subi	r30, 0xC6	; 198
    1fe8:	fa 4f       	sbci	r31, 0xFA	; 250
    1fea:	85 81       	ldd	r24, Z+5	; 0x05
    1fec:	88 1f       	adc	r24, r24
    1fee:	88 27       	eor	r24, r24
    1ff0:	88 1f       	adc	r24, r24
    1ff2:	80 93 4e 05 	sts	0x054E, r24
		vms.var[x]<<=1;
    1ff6:	85 81       	ldd	r24, Z+5	; 0x05
    1ff8:	88 0f       	add	r24, r24
    1ffa:	85 83       	std	Z+5, r24	; 0x05
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
		vms.var[x]=vms.var[y]-vms.var[x];
		break;
	case 0xe: // 8XYE     VX := VX shl 1, VF := carry
		vms.var[15]=(vms.var[x]&128)>>7;
		vms.var[x]<<=1;
		break;
    1ffe:	08 95       	ret
	
	x=rx(b1);
	y=ry(b2);
	switch(b2&0xf){
	case 0: // 8XY0     VX := VY
		vms.var[x]=vms.var[y];
    2000:	b0 e0       	ldi	r27, 0x00	; 0
    2002:	a6 5c       	subi	r26, 0xC6	; 198
    2004:	ba 4f       	sbci	r27, 0xFA	; 250
    2006:	15 96       	adiw	r26, 0x05	; 5
    2008:	9c 91       	ld	r25, X
    200a:	e2 2f       	mov	r30, r18
    200c:	f0 e0       	ldi	r31, 0x00	; 0
    200e:	e6 5c       	subi	r30, 0xC6	; 198
    2010:	fa 4f       	sbci	r31, 0xFA	; 250
    2012:	95 83       	std	Z+5, r25	; 0x05
		break;
    2014:	08 95       	ret
	case 1: // 8XY1     VX := VX OR VY
		vms.var[x]|=vms.var[y];
    2016:	e2 2f       	mov	r30, r18
    2018:	f0 e0       	ldi	r31, 0x00	; 0
    201a:	e6 5c       	subi	r30, 0xC6	; 198
    201c:	fa 4f       	sbci	r31, 0xFA	; 250
    201e:	b0 e0       	ldi	r27, 0x00	; 0
    2020:	a6 5c       	subi	r26, 0xC6	; 198
    2022:	ba 4f       	sbci	r27, 0xFA	; 250
    2024:	85 81       	ldd	r24, Z+5	; 0x05
    2026:	15 96       	adiw	r26, 0x05	; 5
    2028:	9c 91       	ld	r25, X
    202a:	89 2b       	or	r24, r25
    202c:	85 83       	std	Z+5, r24	; 0x05
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    202e:	80 e0       	ldi	r24, 0x00	; 0
	case 0: // 8XY0     VX := VY
		vms.var[x]=vms.var[y];
		break;
	case 1: // 8XY1     VX := VX OR VY
		vms.var[x]|=vms.var[y];
		break;
    2030:	08 95       	ret
	case 2: // 8XY2     VX := VX AND VY
		vms.var[x]&=vms.var[y];
    2032:	e2 2f       	mov	r30, r18
    2034:	f0 e0       	ldi	r31, 0x00	; 0
    2036:	e6 5c       	subi	r30, 0xC6	; 198
    2038:	fa 4f       	sbci	r31, 0xFA	; 250
    203a:	b0 e0       	ldi	r27, 0x00	; 0
    203c:	a6 5c       	subi	r26, 0xC6	; 198
    203e:	ba 4f       	sbci	r27, 0xFA	; 250
    2040:	85 81       	ldd	r24, Z+5	; 0x05
    2042:	15 96       	adiw	r26, 0x05	; 5
    2044:	9c 91       	ld	r25, X
    2046:	89 23       	and	r24, r25
    2048:	85 83       	std	Z+5, r24	; 0x05
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    204a:	80 e0       	ldi	r24, 0x00	; 0
	case 1: // 8XY1     VX := VX OR VY
		vms.var[x]|=vms.var[y];
		break;
	case 2: // 8XY2     VX := VX AND VY
		vms.var[x]&=vms.var[y];
		break;
    204c:	08 95       	ret
	case 3: // 8XY3     VX := VX XOR VY
		vms.var[x]^=vms.var[y];
    204e:	e2 2f       	mov	r30, r18
    2050:	f0 e0       	ldi	r31, 0x00	; 0
    2052:	e6 5c       	subi	r30, 0xC6	; 198
    2054:	fa 4f       	sbci	r31, 0xFA	; 250
    2056:	b0 e0       	ldi	r27, 0x00	; 0
    2058:	a6 5c       	subi	r26, 0xC6	; 198
    205a:	ba 4f       	sbci	r27, 0xFA	; 250
    205c:	85 81       	ldd	r24, Z+5	; 0x05
    205e:	15 96       	adiw	r26, 0x05	; 5
    2060:	9c 91       	ld	r25, X
    2062:	89 27       	eor	r24, r25
    2064:	85 83       	std	Z+5, r24	; 0x05
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    2066:	80 e0       	ldi	r24, 0x00	; 0
	case 2: // 8XY2     VX := VX AND VY
		vms.var[x]&=vms.var[y];
		break;
	case 3: // 8XY3     VX := VX XOR VY
		vms.var[x]^=vms.var[y];
		break;
    2068:	08 95       	ret
	case 4: // 8XY4     VX := VX + VY, VF := carry
		vms.var[15]=0;
    206a:	10 92 4e 05 	sts	0x054E, r1
		if (vms.var[x]+vms.var[y]>255)vms.var[15]=1;
    206e:	e2 2f       	mov	r30, r18
    2070:	f0 e0       	ldi	r31, 0x00	; 0
    2072:	e6 5c       	subi	r30, 0xC6	; 198
    2074:	fa 4f       	sbci	r31, 0xFA	; 250
    2076:	25 81       	ldd	r18, Z+5	; 0x05
    2078:	b0 e0       	ldi	r27, 0x00	; 0
    207a:	a6 5c       	subi	r26, 0xC6	; 198
    207c:	ba 4f       	sbci	r27, 0xFA	; 250
    207e:	15 96       	adiw	r26, 0x05	; 5
    2080:	3c 91       	ld	r19, X
    2082:	15 97       	sbiw	r26, 0x05	; 5
    2084:	83 2f       	mov	r24, r19
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	82 0f       	add	r24, r18
    208a:	91 1d       	adc	r25, r1
    208c:	8f 3f       	cpi	r24, 0xFF	; 255
    208e:	91 05       	cpc	r25, r1
    2090:	39 f0       	breq	.+14     	; 0x20a0 <group8+0xe4>
    2092:	34 f0       	brlt	.+12     	; 0x20a0 <group8+0xe4>
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	80 93 4e 05 	sts	0x054E, r24
    209a:	25 81       	ldd	r18, Z+5	; 0x05
    209c:	15 96       	adiw	r26, 0x05	; 5
    209e:	3c 91       	ld	r19, X
		vms.var[x]+=vms.var[y];
    20a0:	23 0f       	add	r18, r19
    20a2:	25 83       	std	Z+5, r18	; 0x05
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    20a4:	80 e0       	ldi	r24, 0x00	; 0
		break;
	case 4: // 8XY4     VX := VX + VY, VF := carry
		vms.var[15]=0;
		if (vms.var[x]+vms.var[y]>255)vms.var[15]=1;
		vms.var[x]+=vms.var[y];
		break;
    20a6:	08 95       	ret
	case 5: // 8XY5     VX := VX - VY, VF := not borrow
		vms.var[15]=1;
    20a8:	81 e0       	ldi	r24, 0x01	; 1
    20aa:	80 93 4e 05 	sts	0x054E, r24
		if (vms.var[x]<vms.var[y]) vms.var[15]=0;
    20ae:	e2 2f       	mov	r30, r18
    20b0:	f0 e0       	ldi	r31, 0x00	; 0
    20b2:	e6 5c       	subi	r30, 0xC6	; 198
    20b4:	fa 4f       	sbci	r31, 0xFA	; 250
    20b6:	85 81       	ldd	r24, Z+5	; 0x05
    20b8:	b0 e0       	ldi	r27, 0x00	; 0
    20ba:	a6 5c       	subi	r26, 0xC6	; 198
    20bc:	ba 4f       	sbci	r27, 0xFA	; 250
    20be:	15 96       	adiw	r26, 0x05	; 5
    20c0:	9c 91       	ld	r25, X
    20c2:	15 97       	sbiw	r26, 0x05	; 5
    20c4:	89 17       	cp	r24, r25
    20c6:	28 f4       	brcc	.+10     	; 0x20d2 <group8+0x116>
    20c8:	10 92 4e 05 	sts	0x054E, r1
    20cc:	85 81       	ldd	r24, Z+5	; 0x05
    20ce:	15 96       	adiw	r26, 0x05	; 5
    20d0:	9c 91       	ld	r25, X
		vms.var[x]>>=1;
		break;
	case 7: // 8XY7     VX := VY - VX, VF := not borrow
		vms.var[15]=1;
		if (vms.var[y]<vms.var[x])vms.var[15]=0;		
		vms.var[x]=vms.var[y]-vms.var[x];
    20d2:	89 1b       	sub	r24, r25
    20d4:	85 83       	std	Z+5, r24	; 0x05
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    20d6:	80 e0       	ldi	r24, 0x00	; 0
		break;
	case 7: // 8XY7     VX := VY - VX, VF := not borrow
		vms.var[15]=1;
		if (vms.var[y]<vms.var[x])vms.var[15]=0;		
		vms.var[x]=vms.var[y]-vms.var[x];
		break;
    20d8:	08 95       	ret
		vms.var[15]=1;
		if (vms.var[x]<vms.var[y]) vms.var[15]=0;
		vms.var[x]-=vms.var[y];
		break;
	case 6: // 8XY6     VX := VX shr 1, VF := carry
		vms.var[15]=(vms.var[x]&1u);
    20da:	e2 2f       	mov	r30, r18
    20dc:	f0 e0       	ldi	r31, 0x00	; 0
    20de:	e6 5c       	subi	r30, 0xC6	; 198
    20e0:	fa 4f       	sbci	r31, 0xFA	; 250
    20e2:	85 81       	ldd	r24, Z+5	; 0x05
    20e4:	81 70       	andi	r24, 0x01	; 1
    20e6:	80 93 4e 05 	sts	0x054E, r24
		vms.var[x]>>=1;
    20ea:	85 81       	ldd	r24, Z+5	; 0x05
    20ec:	86 95       	lsr	r24
    20ee:	85 83       	std	Z+5, r24	; 0x05
		vms.var[x]<<=1;
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    20f0:	80 e0       	ldi	r24, 0x00	; 0
		vms.var[x]-=vms.var[y];
		break;
	case 6: // 8XY6     VX := VX shr 1, VF := carry
		vms.var[15]=(vms.var[x]&1u);
		vms.var[x]>>=1;
		break;
    20f2:	08 95       	ret
	case 7: // 8XY7     VX := VY - VX, VF := not borrow
		vms.var[15]=1;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	80 93 4e 05 	sts	0x054E, r24
		if (vms.var[y]<vms.var[x])vms.var[15]=0;		
    20fa:	b0 e0       	ldi	r27, 0x00	; 0
    20fc:	a6 5c       	subi	r26, 0xC6	; 198
    20fe:	ba 4f       	sbci	r27, 0xFA	; 250
    2100:	15 96       	adiw	r26, 0x05	; 5
    2102:	8c 91       	ld	r24, X
    2104:	15 97       	sbiw	r26, 0x05	; 5
    2106:	e2 2f       	mov	r30, r18
    2108:	f0 e0       	ldi	r31, 0x00	; 0
    210a:	e6 5c       	subi	r30, 0xC6	; 198
    210c:	fa 4f       	sbci	r31, 0xFA	; 250
    210e:	95 81       	ldd	r25, Z+5	; 0x05
    2110:	89 17       	cp	r24, r25
    2112:	f8 f6       	brcc	.-66     	; 0x20d2 <group8+0x116>
    2114:	10 92 4e 05 	sts	0x054E, r1
    2118:	15 96       	adiw	r26, 0x05	; 5
    211a:	8c 91       	ld	r24, X
    211c:	95 81       	ldd	r25, Z+5	; 0x05
    211e:	d9 cf       	rjmp	.-78     	; 0x20d2 <group8+0x116>

00002120 <groupf>:
	}//switch
	return 0;
}


uint8_t groupf(uint8_t b1, uint8_t b2){
    2120:	cf 93       	push	r28
	uint8_t x, n1;
	
	x=rx(b1);
    2122:	c8 2f       	mov	r28, r24
    2124:	cf 70       	andi	r28, 0x0F	; 15
	switch(b2){
    2126:	69 32       	cpi	r22, 0x29	; 41
    2128:	09 f4       	brne	.+2      	; 0x212c <groupf+0xc>
    212a:	94 c0       	rjmp	.+296    	; 0x2254 <groupf+0x134>
    212c:	78 f0       	brcs	.+30     	; 0x214c <groupf+0x2c>
    212e:	65 35       	cpi	r22, 0x55	; 85
    2130:	b9 f1       	breq	.+110    	; 0x21a0 <groupf+0x80>
    2132:	08 f4       	brcc	.+2      	; 0x2136 <groupf+0x16>
    2134:	5d c0       	rjmp	.+186    	; 0x21f0 <groupf+0xd0>
    2136:	65 37       	cpi	r22, 0x75	; 117
    2138:	09 f4       	brne	.+2      	; 0x213c <groupf+0x1c>
    213a:	40 c0       	rjmp	.+128    	; 0x21bc <groupf+0x9c>
    213c:	65 38       	cpi	r22, 0x85	; 133
    213e:	09 f4       	brne	.+2      	; 0x2142 <groupf+0x22>
    2140:	b6 c0       	rjmp	.+364    	; 0x22ae <groupf+0x18e>
    2142:	65 36       	cpi	r22, 0x65	; 101
    2144:	09 f4       	brne	.+2      	; 0x2148 <groupf+0x28>
    2146:	46 c0       	rjmp	.+140    	; 0x21d4 <groupf+0xb4>
		for (n1=0;n1<=x;n1++){
			vms.var[n1]=vms.rpl[n1];
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
    2148:	81 e0       	ldi	r24, 0x01	; 1
    214a:	19 c0       	rjmp	.+50     	; 0x217e <groupf+0x5e>

uint8_t groupf(uint8_t b1, uint8_t b2){
	uint8_t x, n1;
	
	x=rx(b1);
	switch(b2){
    214c:	65 31       	cpi	r22, 0x15	; 21
    214e:	09 f4       	brne	.+2      	; 0x2152 <groupf+0x32>
    2150:	ba c0       	rjmp	.+372    	; 0x22c6 <groupf+0x1a6>
    2152:	b8 f0       	brcs	.+46     	; 0x2182 <groupf+0x62>
    2154:	68 31       	cpi	r22, 0x18	; 24
    2156:	09 f4       	brne	.+2      	; 0x215a <groupf+0x3a>
    2158:	bf c0       	rjmp	.+382    	; 0x22d8 <groupf+0x1b8>
    215a:	6e 31       	cpi	r22, 0x1E	; 30
    215c:	a9 f7       	brne	.-22     	; 0x2148 <groupf+0x28>
		break;
	case 0x18: // FX18     fait entendre un beep d'une dure VX (multiple de 16.7 msec)
		tone(523,vms.var[x]);
		break;
	case 0x1e: // FX1E     I := I + VX
		vms.ix += vms.var[x];
    215e:	ec 2f       	mov	r30, r28
    2160:	f0 e0       	ldi	r31, 0x00	; 0
    2162:	e6 5c       	subi	r30, 0xC6	; 198
    2164:	fa 4f       	sbci	r31, 0xFA	; 250
    2166:	25 81       	ldd	r18, Z+5	; 0x05
    2168:	80 91 3c 05 	lds	r24, 0x053C
    216c:	90 91 3d 05 	lds	r25, 0x053D
    2170:	82 0f       	add	r24, r18
    2172:	91 1d       	adc	r25, r1
    2174:	90 93 3d 05 	sts	0x053D, r25
    2178:	80 93 3c 05 	sts	0x053C, r24
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    217c:	80 e0       	ldi	r24, 0x00	; 0
}
    217e:	cf 91       	pop	r28
    2180:	08 95       	ret

uint8_t groupf(uint8_t b1, uint8_t b2){
	uint8_t x, n1;
	
	x=rx(b1);
	switch(b2){
    2182:	67 30       	cpi	r22, 0x07	; 7
    2184:	09 f4       	brne	.+2      	; 0x2188 <groupf+0x68>
    2186:	90 c0       	rjmp	.+288    	; 0x22a8 <groupf+0x188>
    2188:	6a 30       	cpi	r22, 0x0A	; 10
    218a:	f1 f6       	brne	.-68     	; 0x2148 <groupf+0x28>
	case 0x07: // FX07     VX := delay_cntr
		vms.var[x]=frame_delay;
		break;
	case 0x0a: // FX0A     attend qu'une touche soit enfonce et met sa valeur dans VX
		vms.var[x]=wait_key();
    218c:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <wait_key>
    2190:	ec 2f       	mov	r30, r28
    2192:	f0 e0       	ldi	r31, 0x00	; 0
    2194:	e6 5c       	subi	r30, 0xC6	; 198
    2196:	fa 4f       	sbci	r31, 0xFA	; 250
    2198:	85 83       	std	Z+5, r24	; 0x05
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    219a:	80 e0       	ldi	r24, 0x00	; 0
}
    219c:	cf 91       	pop	r28
    219e:	08 95       	ret
		block[1]=n1%10;
		block[0]=n1/10;
		sram_store_block(vms.ix,3,block);
		break;
	case 0x55: // FX55     Sauvegarde les registres V0..VX dans la mmoire SRAM  l'adresse M(vms.ix)
		sram_store_block(vms.ix,x+1,vms.var);
    21a0:	6c 2f       	mov	r22, r28
    21a2:	70 e0       	ldi	r23, 0x00	; 0
    21a4:	6f 5f       	subi	r22, 0xFF	; 255
    21a6:	7f 4f       	sbci	r23, 0xFF	; 255
    21a8:	4f e3       	ldi	r20, 0x3F	; 63
    21aa:	55 e0       	ldi	r21, 0x05	; 5
    21ac:	80 91 3c 05 	lds	r24, 0x053C
    21b0:	90 91 3d 05 	lds	r25, 0x053D
    21b4:	0e 94 89 17 	call	0x2f12	; 0x2f12 <sram_store_block>
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    21b8:	80 e0       	ldi	r24, 0x00	; 0
		block[0]=n1/10;
		sram_store_block(vms.ix,3,block);
		break;
	case 0x55: // FX55     Sauvegarde les registres V0..VX dans la mmoire SRAM  l'adresse M(vms.ix)
		sram_store_block(vms.ix,x+1,vms.var);
		break;
    21ba:	e1 cf       	rjmp	.-62     	; 0x217e <groupf+0x5e>

uint8_t groupf(uint8_t b1, uint8_t b2){
	uint8_t x, n1;
	
	x=rx(b1);
	switch(b2){
    21bc:	80 e0       	ldi	r24, 0x00	; 0
	case 0x65: // FX65     charge les registres V0..VX  partir de la mmoire SRAM  l'adresse M(vms.ix)
		sram_load_block(vms.ix,x+1,vms.var);
		break;
	case 0x75: // FX75 (mode schip seulement) sauvegarde les registres V0..VX dans rpl 
		for (n1=0;n1<=x;n1++){
			vms.rpl[n1]=vms.var[n1];
    21be:	e8 2f       	mov	r30, r24
    21c0:	f0 e0       	ldi	r31, 0x00	; 0
    21c2:	e6 5c       	subi	r30, 0xC6	; 198
    21c4:	fa 4f       	sbci	r31, 0xFA	; 250
    21c6:	95 81       	ldd	r25, Z+5	; 0x05
    21c8:	95 8b       	std	Z+21, r25	; 0x15
		break;
	case 0x65: // FX65     charge les registres V0..VX  partir de la mmoire SRAM  l'adresse M(vms.ix)
		sram_load_block(vms.ix,x+1,vms.var);
		break;
	case 0x75: // FX75 (mode schip seulement) sauvegarde les registres V0..VX dans rpl 
		for (n1=0;n1<=x;n1++){
    21ca:	8f 5f       	subi	r24, 0xFF	; 255
    21cc:	c8 17       	cp	r28, r24
    21ce:	b8 f7       	brcc	.-18     	; 0x21be <groupf+0x9e>
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    21d0:	80 e0       	ldi	r24, 0x00	; 0
    21d2:	e4 cf       	rjmp	.-56     	; 0x219c <groupf+0x7c>
		break;
	case 0x55: // FX55     Sauvegarde les registres V0..VX dans la mmoire SRAM  l'adresse M(vms.ix)
		sram_store_block(vms.ix,x+1,vms.var);
		break;
	case 0x65: // FX65     charge les registres V0..VX  partir de la mmoire SRAM  l'adresse M(vms.ix)
		sram_load_block(vms.ix,x+1,vms.var);
    21d4:	6c 2f       	mov	r22, r28
    21d6:	70 e0       	ldi	r23, 0x00	; 0
    21d8:	6f 5f       	subi	r22, 0xFF	; 255
    21da:	7f 4f       	sbci	r23, 0xFF	; 255
    21dc:	4f e3       	ldi	r20, 0x3F	; 63
    21de:	55 e0       	ldi	r21, 0x05	; 5
    21e0:	80 91 3c 05 	lds	r24, 0x053C
    21e4:	90 91 3d 05 	lds	r25, 0x053D
    21e8:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <sram_load_block>
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    21ec:	80 e0       	ldi	r24, 0x00	; 0
	case 0x55: // FX55     Sauvegarde les registres V0..VX dans la mmoire SRAM  l'adresse M(vms.ix)
		sram_store_block(vms.ix,x+1,vms.var);
		break;
	case 0x65: // FX65     charge les registres V0..VX  partir de la mmoire SRAM  l'adresse M(vms.ix)
		sram_load_block(vms.ix,x+1,vms.var);
		break;
    21ee:	c7 cf       	rjmp	.-114    	; 0x217e <groupf+0x5e>

uint8_t groupf(uint8_t b1, uint8_t b2){
	uint8_t x, n1;
	
	x=rx(b1);
	switch(b2){
    21f0:	60 33       	cpi	r22, 0x30	; 48
    21f2:	09 f4       	brne	.+2      	; 0x21f6 <groupf+0xd6>
    21f4:	48 c0       	rjmp	.+144    	; 0x2286 <groupf+0x166>
    21f6:	63 33       	cpi	r22, 0x33	; 51
    21f8:	09 f0       	breq	.+2      	; 0x21fc <groupf+0xdc>
    21fa:	a6 cf       	rjmp	.-180    	; 0x2148 <groupf+0x28>
		vms.ix=(int16_t)font_hex_8x10+vms.var[x]*LHEX_HEIGHT;
		select_font(FONT_LHEX);
		vms.src_mem=FLASH_MEM;
		break;
	case 0x33: // FX33     met la reprsentation BCD de VX dans M(vms.ix)..M(vms.ix+2)
		n1=vms.var[x];
    21fc:	ec 2f       	mov	r30, r28
    21fe:	f0 e0       	ldi	r31, 0x00	; 0
    2200:	e6 5c       	subi	r30, 0xC6	; 198
    2202:	fa 4f       	sbci	r31, 0xFA	; 250
    2204:	25 81       	ldd	r18, Z+5	; 0x05
		block[2]=n1%10;
    2206:	9d ec       	ldi	r25, 0xCD	; 205
    2208:	29 9f       	mul	r18, r25
    220a:	81 2d       	mov	r24, r1
    220c:	11 24       	eor	r1, r1
    220e:	86 95       	lsr	r24
    2210:	86 95       	lsr	r24
    2212:	86 95       	lsr	r24
    2214:	3a e0       	ldi	r19, 0x0A	; 10
    2216:	83 9f       	mul	r24, r19
    2218:	20 19       	sub	r18, r0
    221a:	11 24       	eor	r1, r1
    221c:	20 93 14 01 	sts	0x0114, r18
		n1 /=10;
		block[1]=n1%10;
    2220:	89 9f       	mul	r24, r25
    2222:	91 2d       	mov	r25, r1
    2224:	11 24       	eor	r1, r1
    2226:	96 95       	lsr	r25
    2228:	96 95       	lsr	r25
    222a:	96 95       	lsr	r25
    222c:	2a e0       	ldi	r18, 0x0A	; 10
    222e:	92 9f       	mul	r25, r18
    2230:	80 19       	sub	r24, r0
    2232:	11 24       	eor	r1, r1
    2234:	80 93 13 01 	sts	0x0113, r24
		block[0]=n1/10;
    2238:	90 93 12 01 	sts	0x0112, r25
		sram_store_block(vms.ix,3,block);
    223c:	42 e1       	ldi	r20, 0x12	; 18
    223e:	51 e0       	ldi	r21, 0x01	; 1
    2240:	63 e0       	ldi	r22, 0x03	; 3
    2242:	70 e0       	ldi	r23, 0x00	; 0
    2244:	80 91 3c 05 	lds	r24, 0x053C
    2248:	90 91 3d 05 	lds	r25, 0x053D
    224c:	0e 94 89 17 	call	0x2f12	; 0x2f12 <sram_store_block>
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    2250:	80 e0       	ldi	r24, 0x00	; 0
		block[2]=n1%10;
		n1 /=10;
		block[1]=n1%10;
		block[0]=n1/10;
		sram_store_block(vms.ix,3,block);
		break;
    2252:	95 cf       	rjmp	.-214    	; 0x217e <groupf+0x5e>
		break;
	case 0x1e: // FX1E     I := I + VX
		vms.ix += vms.var[x];
		break;
	case 0x29: // FX29     fait point vms.ix vers le caractre VX dans la police FONT_SHEX
		vms.ix=(int16_t)font_hex_4x6+vms.var[x]*SHEX_HEIGHT;
    2254:	ec 2f       	mov	r30, r28
    2256:	f0 e0       	ldi	r31, 0x00	; 0
    2258:	e6 5c       	subi	r30, 0xC6	; 198
    225a:	fa 4f       	sbci	r31, 0xFA	; 250
    225c:	85 81       	ldd	r24, Z+5	; 0x05
    225e:	26 e0       	ldi	r18, 0x06	; 6
    2260:	82 9f       	mul	r24, r18
    2262:	c0 01       	movw	r24, r0
    2264:	11 24       	eor	r1, r1
    2266:	83 55       	subi	r24, 0x53	; 83
    2268:	91 4e       	sbci	r25, 0xE1	; 225
    226a:	90 93 3d 05 	sts	0x053D, r25
    226e:	80 93 3c 05 	sts	0x053C, r24
		select_font(FONT_SHEX);
    2272:	80 e0       	ldi	r24, 0x00	; 0
		vms.src_mem=FLASH_MEM;
		break;
	case 0x30: // FX30 (schip)    fait point vms.ix vers le caractre dans  VX (0..9) pour la police FONT_LHEX
		vms.ix=(int16_t)font_hex_8x10+vms.var[x]*LHEX_HEIGHT;
		select_font(FONT_LHEX);
    2274:	0e 94 75 15 	call	0x2aea	; 0x2aea <select_font>
		vms.src_mem=FLASH_MEM;
    2278:	80 91 a1 05 	lds	r24, 0x05A1
    227c:	8e 7f       	andi	r24, 0xFE	; 254
    227e:	80 93 a1 05 	sts	0x05A1, r24
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    2282:	80 e0       	ldi	r24, 0x00	; 0
    2284:	8b cf       	rjmp	.-234    	; 0x219c <groupf+0x7c>
		vms.ix=(int16_t)font_hex_4x6+vms.var[x]*SHEX_HEIGHT;
		select_font(FONT_SHEX);
		vms.src_mem=FLASH_MEM;
		break;
	case 0x30: // FX30 (schip)    fait point vms.ix vers le caractre dans  VX (0..9) pour la police FONT_LHEX
		vms.ix=(int16_t)font_hex_8x10+vms.var[x]*LHEX_HEIGHT;
    2286:	ec 2f       	mov	r30, r28
    2288:	f0 e0       	ldi	r31, 0x00	; 0
    228a:	e6 5c       	subi	r30, 0xC6	; 198
    228c:	fa 4f       	sbci	r31, 0xFA	; 250
    228e:	85 81       	ldd	r24, Z+5	; 0x05
    2290:	3a e0       	ldi	r19, 0x0A	; 10
    2292:	83 9f       	mul	r24, r19
    2294:	c0 01       	movw	r24, r0
    2296:	11 24       	eor	r1, r1
    2298:	83 5f       	subi	r24, 0xF3	; 243
    229a:	91 4e       	sbci	r25, 0xE1	; 225
    229c:	90 93 3d 05 	sts	0x053D, r25
    22a0:	80 93 3c 05 	sts	0x053C, r24
		select_font(FONT_LHEX);
    22a4:	81 e0       	ldi	r24, 0x01	; 1
    22a6:	e6 cf       	rjmp	.-52     	; 0x2274 <groupf+0x154>
	uint8_t x, n1;
	
	x=rx(b1);
	switch(b2){
	case 0x07: // FX07     VX := delay_cntr
		vms.var[x]=frame_delay;
    22a8:	80 91 39 01 	lds	r24, 0x0139
    22ac:	71 cf       	rjmp	.-286    	; 0x2190 <groupf+0x70>

uint8_t groupf(uint8_t b1, uint8_t b2){
	uint8_t x, n1;
	
	x=rx(b1);
	switch(b2){
    22ae:	80 e0       	ldi	r24, 0x00	; 0
			vms.rpl[n1]=vms.var[n1];
		}
		break;
	case 0x85: // FX85 (mode schip seulement) charge les registres V0..VX  partir de rpl 
		for (n1=0;n1<=x;n1++){
			vms.var[n1]=vms.rpl[n1];
    22b0:	e8 2f       	mov	r30, r24
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	e6 5c       	subi	r30, 0xC6	; 198
    22b6:	fa 4f       	sbci	r31, 0xFA	; 250
    22b8:	95 89       	ldd	r25, Z+21	; 0x15
    22ba:	95 83       	std	Z+5, r25	; 0x05
		for (n1=0;n1<=x;n1++){
			vms.rpl[n1]=vms.var[n1];
		}
		break;
	case 0x85: // FX85 (mode schip seulement) charge les registres V0..VX  partir de rpl 
		for (n1=0;n1<=x;n1++){
    22bc:	8f 5f       	subi	r24, 0xFF	; 255
    22be:	c8 17       	cp	r28, r24
    22c0:	b8 f7       	brcc	.-18     	; 0x22b0 <groupf+0x190>
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    22c2:	80 e0       	ldi	r24, 0x00	; 0
    22c4:	6b cf       	rjmp	.-298    	; 0x219c <groupf+0x7c>
		break;
	case 0x0a: // FX0A     attend qu'une touche soit enfonce et met sa valeur dans VX
		vms.var[x]=wait_key();
		break;
	case 0x15: // FX15     dmarre la minuterie delay_cntr avec la valeur de dlais VX
		frame_delay=vms.var[x];
    22c6:	ec 2f       	mov	r30, r28
    22c8:	f0 e0       	ldi	r31, 0x00	; 0
    22ca:	e6 5c       	subi	r30, 0xC6	; 198
    22cc:	fa 4f       	sbci	r31, 0xFA	; 250
    22ce:	85 81       	ldd	r24, Z+5	; 0x05
    22d0:	80 93 39 01 	sts	0x0139, r24
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    22d4:	80 e0       	ldi	r24, 0x00	; 0
	case 0x0a: // FX0A     attend qu'une touche soit enfonce et met sa valeur dans VX
		vms.var[x]=wait_key();
		break;
	case 0x15: // FX15     dmarre la minuterie delay_cntr avec la valeur de dlais VX
		frame_delay=vms.var[x];
		break;
    22d6:	53 cf       	rjmp	.-346    	; 0x217e <groupf+0x5e>
	case 0x18: // FX18     fait entendre un beep d'une dure VX (multiple de 16.7 msec)
		tone(523,vms.var[x]);
    22d8:	ec 2f       	mov	r30, r28
    22da:	f0 e0       	ldi	r31, 0x00	; 0
    22dc:	e6 5c       	subi	r30, 0xC6	; 198
    22de:	fa 4f       	sbci	r31, 0xFA	; 250
    22e0:	65 81       	ldd	r22, Z+5	; 0x05
    22e2:	8b e0       	ldi	r24, 0x0B	; 11
    22e4:	92 e0       	ldi	r25, 0x02	; 2
    22e6:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <tone>
		}
		break;
	default:
		return CHIP_BAD_OPCODE;
	}//switch
	return 0;
    22ea:	80 e0       	ldi	r24, 0x00	; 0
	case 0x15: // FX15     dmarre la minuterie delay_cntr avec la valeur de dlais VX
		frame_delay=vms.var[x];
		break;
	case 0x18: // FX18     fait entendre un beep d'une dure VX (multiple de 16.7 msec)
		tone(523,vms.var[x]);
		break;
    22ec:	48 cf       	rjmp	.-368    	; 0x217e <groupf+0x5e>

000022ee <schip>:
	}//switch
	return 0;
}

// machine virtuelle SCHIP
uint8_t schip(){
    22ee:	ef 92       	push	r14
    22f0:	ff 92       	push	r15
    22f2:	0f 93       	push	r16
    22f4:	1f 93       	push	r17
    22f6:	cf 93       	push	r28
    22f8:	df 93       	push	r29
    22fa:	af e3       	ldi	r26, 0x3F	; 63
    22fc:	b5 e0       	ldi	r27, 0x05	; 5
    22fe:	ef e4       	ldi	r30, 0x4F	; 79
    2300:	f5 e0       	ldi	r31, 0x05	; 5
	uint8_t x,y,n3,ipf;
	
	for (n3=0;n3<16;n3++){
		vms.var[n3]=0;
    2302:	1d 92       	st	X+, r1
		vms.rpl[n3]=0;
    2304:	11 92       	st	Z+, r1

// machine virtuelle SCHIP
uint8_t schip(){
	uint8_t x,y,n3,ipf;
	
	for (n3=0;n3<16;n3++){
    2306:	85 e0       	ldi	r24, 0x05	; 5
    2308:	ef 35       	cpi	r30, 0x5F	; 95
    230a:	f8 07       	cpc	r31, r24
    230c:	d1 f7       	brne	.-12     	; 0x2302 <schip+0x14>
		vms.var[n3]=0;
		vms.rpl[n3]=0;
	}
	vms.ix=0;
    230e:	10 92 3d 05 	sts	0x053D, r1
    2312:	10 92 3c 05 	sts	0x053C, r1
	vms.pc=CODE_BASE_ADDR;
    2316:	80 e0       	ldi	r24, 0x00	; 0
    2318:	92 e0       	ldi	r25, 0x02	; 2
    231a:	90 93 3b 05 	sts	0x053B, r25
    231e:	80 93 3a 05 	sts	0x053A, r24
	vms.sp=0;
    2322:	10 92 3e 05 	sts	0x053E, r1
	ipf=255;
	speed_delay=1;
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	80 93 37 01 	sts	0x0137, r24
    232c:	80 e0       	ldi	r24, 0x00	; 0
    232e:	92 e0       	ldi	r25, 0x02	; 2
 	while (1){
		if (!(--ipf)){
    2330:	ce ef       	ldi	r28, 0xFE	; 254
			while (speed_delay);
			speed_delay=1;
			ipf=ADCH;
		}
		vms.opcode=sram_read_word(vms.pc);
    2332:	0e 94 33 17 	call	0x2e66	; 0x2e66 <sram_read_word>
    2336:	80 93 5f 05 	sts	0x055F, r24
    233a:	90 93 60 05 	sts	0x0560, r25
		vms.pc+=2;
    233e:	20 91 3a 05 	lds	r18, 0x053A
    2342:	30 91 3b 05 	lds	r19, 0x053B
    2346:	d9 01       	movw	r26, r18
    2348:	79 01       	movw	r14, r18
    234a:	92 e0       	ldi	r25, 0x02	; 2
    234c:	e9 0e       	add	r14, r25
    234e:	f1 1c       	adc	r15, r1
    2350:	97 01       	movw	r18, r14
    2352:	f0 92 3b 05 	sts	0x053B, r15
    2356:	e0 92 3a 05 	sts	0x053A, r14
		x=rx(vms.b1);
    235a:	18 2f       	mov	r17, r24
    235c:	1f 70       	andi	r17, 0x0F	; 15
		y=ry(vms.b2);
    235e:	d0 91 60 05 	lds	r29, 0x0560
    2362:	0d 2f       	mov	r16, r29
    2364:	02 95       	swap	r16
    2366:	0f 70       	andi	r16, 0x0F	; 15
		switch((vms.b1&0xf0)>>4){
    2368:	48 2f       	mov	r20, r24
    236a:	42 95       	swap	r20
    236c:	4f 70       	andi	r20, 0x0F	; 15
    236e:	50 e0       	ldi	r21, 0x00	; 0
    2370:	4d 5b       	subi	r20, 0xBD	; 189
    2372:	5f 4f       	sbci	r21, 0xFF	; 255
    2374:	fa 01       	movw	r30, r20
    2376:	0c 94 e6 1a 	jmp	0x35cc	; 0x35cc <__tablejump2__>
			break;
		case 1: // 1NNN saut vers l'adresse NNN
			vms.pc=caddr(vms.b1,vms.b2);
			break;
		case 2: // 2NNN  appelle la sous-routine  l'adresse NNN
			vms.stack[++vms.sp]=vms.pc;
    237a:	a0 91 3e 05 	lds	r26, 0x053E
    237e:	af 5f       	subi	r26, 0xFF	; 255
    2380:	a0 93 3e 05 	sts	0x053E, r26
    2384:	b0 e0       	ldi	r27, 0x00	; 0
    2386:	aa 0f       	add	r26, r26
    2388:	bb 1f       	adc	r27, r27
    238a:	a6 5c       	subi	r26, 0xC6	; 198
    238c:	ba 4f       	sbci	r27, 0xFA	; 250
    238e:	98 96       	adiw	r26, 0x28	; 40
    2390:	fc 92       	st	X, r15
    2392:	ee 92       	st	-X, r14
    2394:	97 97       	sbiw	r26, 0x27	; 39
			vms.pc=caddr(vms.b1,vms.b2);
    2396:	21 2f       	mov	r18, r17
    2398:	30 e0       	ldi	r19, 0x00	; 0
    239a:	32 2f       	mov	r19, r18
    239c:	22 27       	eor	r18, r18
    239e:	2d 0f       	add	r18, r29
    23a0:	31 1d       	adc	r19, r1
    23a2:	30 93 3b 05 	sts	0x053B, r19
    23a6:	20 93 3a 05 	sts	0x053A, r18
	vms.pc=CODE_BASE_ADDR;
	vms.sp=0;
	ipf=255;
	speed_delay=1;
 	while (1){
		if (!(--ipf)){
    23aa:	c1 50       	subi	r28, 0x01	; 1
    23ac:	49 f4       	brne	.+18     	; 0x23c0 <schip+0xd2>
			while (speed_delay);
    23ae:	80 91 37 01 	lds	r24, 0x0137
    23b2:	81 11       	cpse	r24, r1
    23b4:	fc cf       	rjmp	.-8      	; 0x23ae <schip+0xc0>
			speed_delay=1;
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	80 93 37 01 	sts	0x0137, r24
			ipf=ADCH;
    23bc:	c0 91 79 00 	lds	r28, 0x0079
    23c0:	c9 01       	movw	r24, r18
    23c2:	b7 cf       	rjmp	.-146    	; 0x2332 <schip+0x44>
		vms.pc+=2;
		x=rx(vms.b1);
		y=ry(vms.b2);
		switch((vms.b1&0xf0)>>4){
		case 0:
			if ((n3=group0(vms.b1, vms.b2))) return n3;
    23c4:	6d 2f       	mov	r22, r29
    23c6:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <group0>
    23ca:	81 11       	cpse	r24, r1
    23cc:	0a c0       	rjmp	.+20     	; 0x23e2 <schip+0xf4>
    23ce:	20 91 3a 05 	lds	r18, 0x053A
    23d2:	30 91 3b 05 	lds	r19, 0x053B
    23d6:	e9 cf       	rjmp	.-46     	; 0x23aa <schip+0xbc>
			default:
				return CHIP_BAD_OPCODE;
			}//swtich
			break;
		case 0xF:
			if ((n3=groupf(vms.b1, vms.b2))) return n3;
    23d8:	6d 2f       	mov	r22, r29
    23da:	0e 94 90 10 	call	0x2120	; 0x2120 <groupf>
    23de:	88 23       	and	r24, r24
    23e0:	b1 f3       	breq	.-20     	; 0x23ce <schip+0xe0>
			break;
		default:
			return CHIP_BAD_OPCODE;
		}//switch
	}//while(1)
}
    23e2:	df 91       	pop	r29
    23e4:	cf 91       	pop	r28
    23e6:	1f 91       	pop	r17
    23e8:	0f 91       	pop	r16
    23ea:	ff 90       	pop	r15
    23ec:	ef 90       	pop	r14
    23ee:	08 95       	ret
					vms.var[15]=put_sprite(vms.var[x],vms.var[y],n3,(const uint8_t*)block,RAM_MEM);
				}
			}
			break;
		case 0xE:
			switch(vms.b2){
    23f0:	de 39       	cpi	r29, 0x9E	; 158
    23f2:	09 f4       	brne	.+2      	; 0x23f6 <schip+0x108>
    23f4:	c1 c0       	rjmp	.+386    	; 0x2578 <schip+0x28a>
    23f6:	d1 3a       	cpi	r29, 0xA1	; 161
    23f8:	09 f0       	breq	.+2      	; 0x23fc <schip+0x10e>
    23fa:	c8 c0       	rjmp	.+400    	; 0x258c <schip+0x29e>
			case 0x9e: //EX9E, saute l'instruction suivante si la touche VX est enfonce
				n3=keypad_read();
				if (vms.var[x]==n3) vms.pc+=2;
				break;
			case 0xa1: //EXA1, saute l'instruction suivante si la touche VX n'est pas enfonce
				n3=keypad_read();
    23fc:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
				if (vms.var[x]!=n3) vms.pc+=2;
    2400:	e1 2f       	mov	r30, r17
    2402:	f0 e0       	ldi	r31, 0x00	; 0
    2404:	e6 5c       	subi	r30, 0xC6	; 198
    2406:	fa 4f       	sbci	r31, 0xFA	; 250
    2408:	95 81       	ldd	r25, Z+5	; 0x05
    240a:	98 17       	cp	r25, r24
    240c:	01 f3       	breq	.-64     	; 0x23ce <schip+0xe0>
    240e:	20 91 3a 05 	lds	r18, 0x053A
    2412:	30 91 3b 05 	lds	r19, 0x053B
    2416:	2e 5f       	subi	r18, 0xFE	; 254
    2418:	3f 4f       	sbci	r19, 0xFF	; 255
    241a:	30 93 3b 05 	sts	0x053B, r19
    241e:	20 93 3a 05 	sts	0x053A, r18
    2422:	c3 cf       	rjmp	.-122    	; 0x23aa <schip+0xbc>
			break;
		case 0xC: //CXKK VX=random_number&KK
			vms.var[x]=rand()&vms.b2;
			break;
		case 0xD: //DXYN dessine un sprite
			n3=vms.b2&0xf;
    2424:	df 70       	andi	r29, 0x0F	; 15
			if (!n3){
    2426:	09 f4       	brne	.+2      	; 0x242a <schip+0x13c>
    2428:	b9 c0       	rjmp	.+370    	; 0x259c <schip+0x2ae>
				sram_load_block(vms.ix,32,block);
				vms.var[15]=put_big_sprite(vms.var[x],vms.var[y],(const uint8_t*)block);				
			}else{
				if (vms.src_mem==FLASH_MEM){
    242a:	80 91 a1 05 	lds	r24, 0x05A1
    242e:	80 ff       	sbrs	r24, 0
    2430:	95 c0       	rjmp	.+298    	; 0x255c <schip+0x26e>
					vms.var[15]=put_sprite(vms.var[x],vms.var[y],n3,(const uint8_t *)vms.ix,FLASH_MEM);
				}else{
					sram_load_block(vms.ix,n3,block);
    2432:	6d 2f       	mov	r22, r29
    2434:	70 e0       	ldi	r23, 0x00	; 0
    2436:	42 e1       	ldi	r20, 0x12	; 18
    2438:	51 e0       	ldi	r21, 0x01	; 1
    243a:	80 91 3c 05 	lds	r24, 0x053C
    243e:	90 91 3d 05 	lds	r25, 0x053D
    2442:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <sram_load_block>
					vms.var[15]=put_sprite(vms.var[x],vms.var[y],n3,(const uint8_t*)block,RAM_MEM);
    2446:	a0 2f       	mov	r26, r16
    2448:	b0 e0       	ldi	r27, 0x00	; 0
    244a:	a6 5c       	subi	r26, 0xC6	; 198
    244c:	ba 4f       	sbci	r27, 0xFA	; 250
    244e:	e1 2f       	mov	r30, r17
    2450:	f0 e0       	ldi	r31, 0x00	; 0
    2452:	e6 5c       	subi	r30, 0xC6	; 198
    2454:	fa 4f       	sbci	r31, 0xFA	; 250
    2456:	01 e0       	ldi	r16, 0x01	; 1
    2458:	22 e1       	ldi	r18, 0x12	; 18
    245a:	31 e0       	ldi	r19, 0x01	; 1
			if (!n3){
				sram_load_block(vms.ix,32,block);
				vms.var[15]=put_big_sprite(vms.var[x],vms.var[y],(const uint8_t*)block);				
			}else{
				if (vms.src_mem==FLASH_MEM){
					vms.var[15]=put_sprite(vms.var[x],vms.var[y],n3,(const uint8_t *)vms.ix,FLASH_MEM);
    245c:	4d 2f       	mov	r20, r29
    245e:	15 96       	adiw	r26, 0x05	; 5
    2460:	6c 91       	ld	r22, X
    2462:	85 81       	ldd	r24, Z+5	; 0x05
    2464:	0e 94 e7 17 	call	0x2fce	; 0x2fce <put_sprite>
    2468:	80 93 4e 05 	sts	0x054E, r24
    246c:	b0 cf       	rjmp	.-160    	; 0x23ce <schip+0xe0>
			break;
		case 0xB: // BNNN     saut  NNN+V0
			vms.pc=vms.var[0]+caddr(vms.b1,vms.b2);
			break;
		case 0xC: //CXKK VX=random_number&KK
			vms.var[x]=rand()&vms.b2;
    246e:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <rand>
    2472:	e1 2f       	mov	r30, r17
    2474:	f0 e0       	ldi	r31, 0x00	; 0
    2476:	e6 5c       	subi	r30, 0xC6	; 198
    2478:	fa 4f       	sbci	r31, 0xFA	; 250
    247a:	90 91 60 05 	lds	r25, 0x0560
    247e:	98 23       	and	r25, r24
    2480:	95 83       	std	Z+5, r25	; 0x05
    2482:	20 91 3a 05 	lds	r18, 0x053A
    2486:	30 91 3b 05 	lds	r19, 0x053B
			break;
    248a:	8f cf       	rjmp	.-226    	; 0x23aa <schip+0xbc>
		case 0xA: // ANNN     I := NNN 
			vms.ix=caddr(vms.b1,vms.b2);  // chip-8 et schip adressse de 12 bits
			vms.src_mem=RAM_MEM;
			break;
		case 0xB: // BNNN     saut  NNN+V0
			vms.pc=vms.var[0]+caddr(vms.b1,vms.b2);
    248c:	80 91 3f 05 	lds	r24, 0x053F
    2490:	21 2f       	mov	r18, r17
    2492:	30 e0       	ldi	r19, 0x00	; 0
    2494:	32 2f       	mov	r19, r18
    2496:	22 27       	eor	r18, r18
    2498:	2d 0f       	add	r18, r29
    249a:	31 1d       	adc	r19, r1
    249c:	28 0f       	add	r18, r24
    249e:	31 1d       	adc	r19, r1
    24a0:	30 93 3b 05 	sts	0x053B, r19
    24a4:	20 93 3a 05 	sts	0x053A, r18
			break;
    24a8:	80 cf       	rjmp	.-256    	; 0x23aa <schip+0xbc>
			break;
		case 9: // 9XY0     Saute l'instruction suivante si VX <> VY
			if (vms.var[x]!=vms.var[y]) vms.pc+=2;
			break;
		case 0xA: // ANNN     I := NNN 
			vms.ix=caddr(vms.b1,vms.b2);  // chip-8 et schip adressse de 12 bits
    24aa:	81 2f       	mov	r24, r17
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    24ae:	98 2f       	mov	r25, r24
    24b0:	88 27       	eor	r24, r24
    24b2:	8d 0f       	add	r24, r29
    24b4:	91 1d       	adc	r25, r1
    24b6:	90 93 3d 05 	sts	0x053D, r25
    24ba:	80 93 3c 05 	sts	0x053C, r24
			vms.src_mem=RAM_MEM;
    24be:	80 91 a1 05 	lds	r24, 0x05A1
    24c2:	81 60       	ori	r24, 0x01	; 1
    24c4:	80 93 a1 05 	sts	0x05A1, r24
			break;
    24c8:	70 cf       	rjmp	.-288    	; 0x23aa <schip+0xbc>
			break;
		case 8: 
			if ((n3=group8(vms.b1,vms.b2))) return n3;
			break;
		case 9: // 9XY0     Saute l'instruction suivante si VX <> VY
			if (vms.var[x]!=vms.var[y]) vms.pc+=2;
    24ca:	81 2f       	mov	r24, r17
    24cc:	90 e0       	ldi	r25, 0x00	; 0
    24ce:	86 5c       	subi	r24, 0xC6	; 198
    24d0:	9a 4f       	sbci	r25, 0xFA	; 250
    24d2:	10 e0       	ldi	r17, 0x00	; 0
    24d4:	06 5c       	subi	r16, 0xC6	; 198
    24d6:	1a 4f       	sbci	r17, 0xFA	; 250
    24d8:	fc 01       	movw	r30, r24
    24da:	95 81       	ldd	r25, Z+5	; 0x05
    24dc:	f8 01       	movw	r30, r16
    24de:	85 81       	ldd	r24, Z+5	; 0x05
    24e0:	98 17       	cp	r25, r24
    24e2:	09 f4       	brne	.+2      	; 0x24e6 <schip+0x1f8>
    24e4:	62 cf       	rjmp	.-316    	; 0x23aa <schip+0xbc>
    24e6:	9d 01       	movw	r18, r26
    24e8:	2c 5f       	subi	r18, 0xFC	; 252
    24ea:	3f 4f       	sbci	r19, 0xFF	; 255
    24ec:	30 93 3b 05 	sts	0x053B, r19
    24f0:	20 93 3a 05 	sts	0x053A, r18
    24f4:	5a cf       	rjmp	.-332    	; 0x23aa <schip+0xbc>
			break;
		case 7: // 7XKK     VX := VX + KK
			vms.var[x]+=vms.b2;
			break;
		case 8: 
			if ((n3=group8(vms.b1,vms.b2))) return n3;
    24f6:	6d 2f       	mov	r22, r29
    24f8:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <group8>
    24fc:	88 23       	and	r24, r24
    24fe:	09 f4       	brne	.+2      	; 0x2502 <schip+0x214>
    2500:	66 cf       	rjmp	.-308    	; 0x23ce <schip+0xe0>
    2502:	6f cf       	rjmp	.-290    	; 0x23e2 <schip+0xf4>
			break;
		case 6: // 6XKK     VX := KK 
			vms.var[x]=vms.b2;
			break;
		case 7: // 7XKK     VX := VX + KK
			vms.var[x]+=vms.b2;
    2504:	e1 2f       	mov	r30, r17
    2506:	f0 e0       	ldi	r31, 0x00	; 0
    2508:	e6 5c       	subi	r30, 0xC6	; 198
    250a:	fa 4f       	sbci	r31, 0xFA	; 250
    250c:	85 81       	ldd	r24, Z+5	; 0x05
    250e:	8d 0f       	add	r24, r29
    2510:	85 83       	std	Z+5, r24	; 0x05
			break;
    2512:	4b cf       	rjmp	.-362    	; 0x23aa <schip+0xbc>
			break;
		case 5: // 5XY0     Saute l'instruction suivante si VX == VY
			if (vms.var[x]==vms.var[y]) vms.pc+=2;
			break;
		case 6: // 6XKK     VX := KK 
			vms.var[x]=vms.b2;
    2514:	e1 2f       	mov	r30, r17
    2516:	f0 e0       	ldi	r31, 0x00	; 0
    2518:	e6 5c       	subi	r30, 0xC6	; 198
    251a:	fa 4f       	sbci	r31, 0xFA	; 250
    251c:	d5 83       	std	Z+5, r29	; 0x05
			break;
    251e:	45 cf       	rjmp	.-374    	; 0x23aa <schip+0xbc>
			break;
		case 4: // 4XKK  Saute l'instruction suivante si VX <> KK 
			if (vms.var[x]!=vms.b2) vms.pc+=2;
			break;
		case 5: // 5XY0     Saute l'instruction suivante si VX == VY
			if (vms.var[x]==vms.var[y]) vms.pc+=2;
    2520:	81 2f       	mov	r24, r17
    2522:	90 e0       	ldi	r25, 0x00	; 0
    2524:	86 5c       	subi	r24, 0xC6	; 198
    2526:	9a 4f       	sbci	r25, 0xFA	; 250
    2528:	10 e0       	ldi	r17, 0x00	; 0
    252a:	06 5c       	subi	r16, 0xC6	; 198
    252c:	1a 4f       	sbci	r17, 0xFA	; 250
    252e:	fc 01       	movw	r30, r24
    2530:	95 81       	ldd	r25, Z+5	; 0x05
    2532:	f8 01       	movw	r30, r16
    2534:	85 81       	ldd	r24, Z+5	; 0x05
    2536:	98 13       	cpse	r25, r24
    2538:	38 cf       	rjmp	.-400    	; 0x23aa <schip+0xbc>
    253a:	d5 cf       	rjmp	.-86     	; 0x24e6 <schip+0x1f8>
			break;
		case 3: // 3XKK   saute l'instruction suivante si VX == KK 
			if (vms.var[x]==vms.b2) vms.pc+=2;
			break;
		case 4: // 4XKK  Saute l'instruction suivante si VX <> KK 
			if (vms.var[x]!=vms.b2) vms.pc+=2;
    253c:	e1 2f       	mov	r30, r17
    253e:	f0 e0       	ldi	r31, 0x00	; 0
    2540:	e6 5c       	subi	r30, 0xC6	; 198
    2542:	fa 4f       	sbci	r31, 0xFA	; 250
    2544:	85 81       	ldd	r24, Z+5	; 0x05
    2546:	d8 13       	cpse	r29, r24
    2548:	ce cf       	rjmp	.-100    	; 0x24e6 <schip+0x1f8>
    254a:	2f cf       	rjmp	.-418    	; 0x23aa <schip+0xbc>
		case 2: // 2NNN  appelle la sous-routine  l'adresse NNN
			vms.stack[++vms.sp]=vms.pc;
			vms.pc=caddr(vms.b1,vms.b2);
			break;
		case 3: // 3XKK   saute l'instruction suivante si VX == KK 
			if (vms.var[x]==vms.b2) vms.pc+=2;
    254c:	e1 2f       	mov	r30, r17
    254e:	f0 e0       	ldi	r31, 0x00	; 0
    2550:	e6 5c       	subi	r30, 0xC6	; 198
    2552:	fa 4f       	sbci	r31, 0xFA	; 250
    2554:	85 81       	ldd	r24, Z+5	; 0x05
    2556:	d8 13       	cpse	r29, r24
    2558:	28 cf       	rjmp	.-432    	; 0x23aa <schip+0xbc>
    255a:	c5 cf       	rjmp	.-118    	; 0x24e6 <schip+0x1f8>
			if (!n3){
				sram_load_block(vms.ix,32,block);
				vms.var[15]=put_big_sprite(vms.var[x],vms.var[y],(const uint8_t*)block);				
			}else{
				if (vms.src_mem==FLASH_MEM){
					vms.var[15]=put_sprite(vms.var[x],vms.var[y],n3,(const uint8_t *)vms.ix,FLASH_MEM);
    255c:	20 91 3c 05 	lds	r18, 0x053C
    2560:	30 91 3d 05 	lds	r19, 0x053D
    2564:	a0 2f       	mov	r26, r16
    2566:	b0 e0       	ldi	r27, 0x00	; 0
    2568:	a6 5c       	subi	r26, 0xC6	; 198
    256a:	ba 4f       	sbci	r27, 0xFA	; 250
    256c:	e1 2f       	mov	r30, r17
    256e:	f0 e0       	ldi	r31, 0x00	; 0
    2570:	e6 5c       	subi	r30, 0xC6	; 198
    2572:	fa 4f       	sbci	r31, 0xFA	; 250
    2574:	00 e0       	ldi	r16, 0x00	; 0
    2576:	72 cf       	rjmp	.-284    	; 0x245c <schip+0x16e>
			}
			break;
		case 0xE:
			switch(vms.b2){
			case 0x9e: //EX9E, saute l'instruction suivante si la touche VX est enfonce
				n3=keypad_read();
    2578:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
				if (vms.var[x]==n3) vms.pc+=2;
    257c:	e1 2f       	mov	r30, r17
    257e:	f0 e0       	ldi	r31, 0x00	; 0
    2580:	e6 5c       	subi	r30, 0xC6	; 198
    2582:	fa 4f       	sbci	r31, 0xFA	; 250
    2584:	95 81       	ldd	r25, Z+5	; 0x05
    2586:	98 13       	cpse	r25, r24
    2588:	22 cf       	rjmp	.-444    	; 0x23ce <schip+0xe0>
    258a:	41 cf       	rjmp	.-382    	; 0x240e <schip+0x120>
			case 0xa1: //EXA1, saute l'instruction suivante si la touche VX n'est pas enfonce
				n3=keypad_read();
				if (vms.var[x]!=n3) vms.pc+=2;
				break;
			default:
				return CHIP_BAD_OPCODE;
    258c:	81 e0       	ldi	r24, 0x01	; 1
			break;
		default:
			return CHIP_BAD_OPCODE;
		}//switch
	}//while(1)
}
    258e:	df 91       	pop	r29
    2590:	cf 91       	pop	r28
    2592:	1f 91       	pop	r17
    2594:	0f 91       	pop	r16
    2596:	ff 90       	pop	r15
    2598:	ef 90       	pop	r14
    259a:	08 95       	ret
			vms.var[x]=rand()&vms.b2;
			break;
		case 0xD: //DXYN dessine un sprite
			n3=vms.b2&0xf;
			if (!n3){
				sram_load_block(vms.ix,32,block);
    259c:	42 e1       	ldi	r20, 0x12	; 18
    259e:	51 e0       	ldi	r21, 0x01	; 1
    25a0:	60 e2       	ldi	r22, 0x20	; 32
    25a2:	70 e0       	ldi	r23, 0x00	; 0
    25a4:	80 91 3c 05 	lds	r24, 0x053C
    25a8:	90 91 3d 05 	lds	r25, 0x053D
    25ac:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <sram_load_block>
				vms.var[15]=put_big_sprite(vms.var[x],vms.var[y],(const uint8_t*)block);				
    25b0:	a0 2f       	mov	r26, r16
    25b2:	b0 e0       	ldi	r27, 0x00	; 0
    25b4:	a6 5c       	subi	r26, 0xC6	; 198
    25b6:	ba 4f       	sbci	r27, 0xFA	; 250
    25b8:	e1 2f       	mov	r30, r17
    25ba:	f0 e0       	ldi	r31, 0x00	; 0
    25bc:	e6 5c       	subi	r30, 0xC6	; 198
    25be:	fa 4f       	sbci	r31, 0xFA	; 250
    25c0:	42 e1       	ldi	r20, 0x12	; 18
    25c2:	51 e0       	ldi	r21, 0x01	; 1
    25c4:	15 96       	adiw	r26, 0x05	; 5
    25c6:	6c 91       	ld	r22, X
    25c8:	85 81       	ldd	r24, Z+5	; 0x05
    25ca:	0e 94 68 18 	call	0x30d0	; 0x30d0 <put_big_sprite>
    25ce:	80 93 4e 05 	sts	0x054E, r24
    25d2:	20 91 3a 05 	lds	r18, 0x053A
    25d6:	30 91 3b 05 	lds	r19, 0x053B
    25da:	e7 ce       	rjmp	.-562    	; 0x23aa <schip+0xbc>

000025dc <print_vms>:


extern vm_state_t vms;

void print_vms(){
		cls();
    25dc:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
		select_font(FONT_ASCII);
    25e0:	82 e0       	ldi	r24, 0x02	; 2
    25e2:	0e 94 75 15 	call	0x2aea	; 0x2aea <select_font>
		print_hex(vms.pc-2,4);
    25e6:	80 91 3a 05 	lds	r24, 0x053A
    25ea:	90 91 3b 05 	lds	r25, 0x053B
    25ee:	64 e0       	ldi	r22, 0x04	; 4
    25f0:	02 97       	sbiw	r24, 0x02	; 2
    25f2:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <print_hex>
		//print((uint8_t*)" ");
		print_hex(vms.opcode,4);
    25f6:	64 e0       	ldi	r22, 0x04	; 4
    25f8:	80 91 5f 05 	lds	r24, 0x055F
    25fc:	90 91 60 05 	lds	r25, 0x0560
    2600:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <print_hex>
		print((uint8_t*)" code error\n");
    2604:	85 e0       	ldi	r24, 0x05	; 5
    2606:	91 e0       	ldi	r25, 0x01	; 1
    2608:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <print>
	    prompt_key();
    260c:	0c 94 59 15 	jmp	0x2ab2	; 0x2ab2 <prompt_key>

00002610 <load_flash_game>:
}

void load_flash_game(uint8_t *addr,uint16_t size){
    2610:	ef 92       	push	r14
    2612:	ff 92       	push	r15
    2614:	0f 93       	push	r16
    2616:	1f 93       	push	r17
    2618:	cf 93       	push	r28
    261a:	df 93       	push	r29
	uint16_t i;
	for (i=0;i<size;i++){
    261c:	61 15       	cp	r22, r1
    261e:	71 05       	cpc	r23, r1
    2620:	89 f0       	breq	.+34     	; 0x2644 <load_flash_game+0x34>
    2622:	8c 01       	movw	r16, r24
    2624:	7b 01       	movw	r14, r22
    2626:	8e ef       	ldi	r24, 0xFE	; 254
    2628:	f8 1a       	sub	r15, r24
    262a:	c0 e0       	ldi	r28, 0x00	; 0
    262c:	d2 e0       	ldi	r29, 0x02	; 2
		sram_write_byte(CODE_BASE_ADDR+i,pgm_read_byte(&addr[i]));
    262e:	f8 01       	movw	r30, r16
    2630:	64 91       	lpm	r22, Z
    2632:	ce 01       	movw	r24, r28
    2634:	0e 94 13 17 	call	0x2e26	; 0x2e26 <sram_write_byte>
    2638:	0f 5f       	subi	r16, 0xFF	; 255
    263a:	1f 4f       	sbci	r17, 0xFF	; 255
    263c:	21 96       	adiw	r28, 0x01	; 1
	    prompt_key();
}

void load_flash_game(uint8_t *addr,uint16_t size){
	uint16_t i;
	for (i=0;i<size;i++){
    263e:	ce 15       	cp	r28, r14
    2640:	df 05       	cpc	r29, r15
    2642:	a9 f7       	brne	.-22     	; 0x262e <load_flash_game+0x1e>
		sram_write_byte(CODE_BASE_ADDR+i,pgm_read_byte(&addr[i]));
	}
}
    2644:	df 91       	pop	r29
    2646:	cf 91       	pop	r28
    2648:	1f 91       	pop	r17
    264a:	0f 91       	pop	r16
    264c:	ff 90       	pop	r15
    264e:	ef 90       	pop	r14
    2650:	08 95       	ret

00002652 <display_page>:
#define MAX_ENTRIES (2048)
#define DISPLAY_LINES (8)



uint8_t display_page(int16_t page){
    2652:	ff 92       	push	r15
    2654:	0f 93       	push	r16
    2656:	1f 93       	push	r17
    2658:	cf 93       	push	r28
    265a:	df 93       	push	r29
    265c:	cd b7       	in	r28, 0x3d	; 61
    265e:	de b7       	in	r29, 0x3e	; 62
    2660:	a0 97       	sbiw	r28, 0x20	; 32
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	de bf       	out	0x3e, r29	; 62
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	cd bf       	out	0x3d, r28	; 61
    266c:	18 2f       	mov	r17, r24
    266e:	00 27       	eor	r16, r16
	uint8_t fname[ENTRY_SIZE];
	uint8_t i;
	for (i=0;i<DISPLAY_LINES;i++){
    2670:	f1 2c       	mov	r15, r1
		sram_load_block(page*DISPLAY_LINES*ENTRY_SIZE+(i*ENTRY_SIZE),ENTRY_SIZE,fname);
    2672:	ae 01       	movw	r20, r28
    2674:	4f 5f       	subi	r20, 0xFF	; 255
    2676:	5f 4f       	sbci	r21, 0xFF	; 255
    2678:	60 e2       	ldi	r22, 0x20	; 32
    267a:	70 e0       	ldi	r23, 0x00	; 0
    267c:	c8 01       	movw	r24, r16
    267e:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <sram_load_block>
		if (strlen((char *)fname)){
    2682:	89 81       	ldd	r24, Y+1	; 0x01
    2684:	88 23       	and	r24, r24
    2686:	91 f0       	breq	.+36     	; 0x26ac <display_page+0x5a>
			put_char(' ');
    2688:	80 e2       	ldi	r24, 0x20	; 32
    268a:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <put_char>
			print(fname);
    268e:	ce 01       	movw	r24, r28
    2690:	01 96       	adiw	r24, 0x01	; 1
    2692:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <print>
			if (i<7) new_line();
    2696:	87 e0       	ldi	r24, 0x07	; 7
    2698:	f8 16       	cp	r15, r24
    269a:	31 f0       	breq	.+12     	; 0x26a8 <display_page+0x56>
    269c:	0e 94 78 15 	call	0x2af0	; 0x2af0 <new_line>


uint8_t display_page(int16_t page){
	uint8_t fname[ENTRY_SIZE];
	uint8_t i;
	for (i=0;i<DISPLAY_LINES;i++){
    26a0:	f3 94       	inc	r15
    26a2:	00 5e       	subi	r16, 0xE0	; 224
    26a4:	1f 4f       	sbci	r17, 0xFF	; 255
    26a6:	e5 cf       	rjmp	.-54     	; 0x2672 <display_page+0x20>
    26a8:	88 e0       	ldi	r24, 0x08	; 8
    26aa:	f8 2e       	mov	r15, r24
		}else{
			break;
		}
	}
	return i;
}
    26ac:	8f 2d       	mov	r24, r15
    26ae:	a0 96       	adiw	r28, 0x20	; 32
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	f8 94       	cli
    26b4:	de bf       	out	0x3e, r29	; 62
    26b6:	0f be       	out	0x3f, r0	; 63
    26b8:	cd bf       	out	0x3d, r28	; 61
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	1f 91       	pop	r17
    26c0:	0f 91       	pop	r16
    26c2:	ff 90       	pop	r15
    26c4:	08 95       	ret

000026c6 <select_file>:
}

// slectionne un fichier
//  partir de la liste
// affiche  l'cran
int16_t select_file(int16_t fcount){
    26c6:	af 92       	push	r10
    26c8:	bf 92       	push	r11
    26ca:	cf 92       	push	r12
    26cc:	df 92       	push	r13
    26ce:	ef 92       	push	r14
    26d0:	ff 92       	push	r15
    26d2:	0f 93       	push	r16
    26d4:	1f 93       	push	r17
    26d6:	cf 93       	push	r28
    26d8:	df 93       	push	r29
    26da:	6c 01       	movw	r12, r24
	int16_t page, selected;
	uint8_t key, pg_lines;
	
	prt_pstr(PSTR("'A' selection\n"));
    26dc:	81 ef       	ldi	r24, 0xF1	; 241
    26de:	90 e0       	ldi	r25, 0x00	; 0
    26e0:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <prt_pstr>
	prt_pstr(PSTR("'*' page precedante\n"));
    26e4:	8c ed       	ldi	r24, 0xDC	; 220
    26e6:	90 e0       	ldi	r25, 0x00	; 0
    26e8:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <prt_pstr>
	prt_pstr(PSTR("'#' page suivante\n"));
    26ec:	89 ec       	ldi	r24, 0xC9	; 201
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <prt_pstr>
	prt_pstr(PSTR("'7' vers le haut\n"));
    26f4:	87 eb       	ldi	r24, 0xB7	; 183
    26f6:	90 e0       	ldi	r25, 0x00	; 0
    26f8:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <prt_pstr>
	prt_pstr(PSTR("'9' vers le bas\n"));
    26fc:	86 ea       	ldi	r24, 0xA6	; 166
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <prt_pstr>
	prompt_key();
    2704:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <prompt_key>
	cls();
    2708:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
	page=0;
	selected=0;
	frame_delay=2;
    270c:	82 e0       	ldi	r24, 0x02	; 2
    270e:	80 93 39 01 	sts	0x0139, r24
	while (frame_delay);
    2712:	80 91 39 01 	lds	r24, 0x0139
    2716:	81 11       	cpse	r24, r1
    2718:	fc cf       	rjmp	.-8      	; 0x2712 <select_file+0x4c>
	pg_lines=display_page(page);
    271a:	80 e0       	ldi	r24, 0x00	; 0
    271c:	90 e0       	ldi	r25, 0x00	; 0
    271e:	0e 94 29 13 	call	0x2652	; 0x2652 <display_page>
    2722:	b8 2e       	mov	r11, r24
	prt_pstr(PSTR("'7' vers le haut\n"));
	prt_pstr(PSTR("'9' vers le bas\n"));
	prompt_key();
	cls();
	page=0;
	selected=0;
    2724:	c0 e0       	ldi	r28, 0x00	; 0
    2726:	d0 e0       	ldi	r29, 0x00	; 0
	prt_pstr(PSTR("'#' page suivante\n"));
	prt_pstr(PSTR("'7' vers le haut\n"));
	prt_pstr(PSTR("'9' vers le bas\n"));
	prompt_key();
	cls();
	page=0;
    2728:	e1 2c       	mov	r14, r1
    272a:	f1 2c       	mov	r15, r1
    272c:	a1 2c       	mov	r10, r1
	}
	return i;
}

inline void display_cursor(uint8_t line){
	put_sprite(0,line*CHAR_HEIGHT,8,&font_6x8[(RIGHT_ARROW-32)*CHAR_HEIGHT],FLASH_MEM);
    272e:	00 e0       	ldi	r16, 0x00	; 0
    2730:	25 ee       	ldi	r18, 0xE5	; 229
    2732:	3d e1       	ldi	r19, 0x1D	; 29
    2734:	48 e0       	ldi	r20, 0x08	; 8
    2736:	6a 2d       	mov	r22, r10
    2738:	80 e0       	ldi	r24, 0x00	; 0
    273a:	0e 94 e7 17 	call	0x2fce	; 0x2fce <put_sprite>
	frame_delay=2;
	while (frame_delay);
	pg_lines=display_page(page);
	while (1){
		display_cursor(selected);
		key=wait_key();
    273e:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <wait_key>
    2742:	18 2f       	mov	r17, r24
		tone(key,6);
    2744:	66 e0       	ldi	r22, 0x06	; 6
    2746:	90 e0       	ldi	r25, 0x00	; 0
    2748:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <tone>
	}
	return i;
}

inline void display_cursor(uint8_t line){
	put_sprite(0,line*CHAR_HEIGHT,8,&font_6x8[(RIGHT_ARROW-32)*CHAR_HEIGHT],FLASH_MEM);
    274c:	25 ee       	ldi	r18, 0xE5	; 229
    274e:	3d e1       	ldi	r19, 0x1D	; 29
    2750:	48 e0       	ldi	r20, 0x08	; 8
    2752:	6a 2d       	mov	r22, r10
    2754:	80 e0       	ldi	r24, 0x00	; 0
    2756:	0e 94 e7 17 	call	0x2fce	; 0x2fce <put_sprite>
	while (1){
		display_cursor(selected);
		key=wait_key();
		tone(key,6);
		display_cursor(selected);
		switch(key){
    275a:	1a 30       	cpi	r17, 0x0A	; 10
    275c:	09 f4       	brne	.+2      	; 0x2760 <select_file+0x9a>
    275e:	40 c0       	rjmp	.+128    	; 0x27e0 <select_file+0x11a>
    2760:	b8 f4       	brcc	.+46     	; 0x2790 <select_file+0xca>
    2762:	17 30       	cpi	r17, 0x07	; 7
    2764:	71 f1       	breq	.+92     	; 0x27c2 <select_file+0xfc>
    2766:	19 30       	cpi	r17, 0x09	; 9
    2768:	69 f4       	brne	.+26     	; 0x2784 <select_file+0xbe>
				cls();
				pg_lines=display_page(page);
			}
			break;
		case 9: // DOWN_ARROW
			if (selected<(pg_lines-1)){
    276a:	2b 2d       	mov	r18, r11
    276c:	30 e0       	ldi	r19, 0x00	; 0
    276e:	21 50       	subi	r18, 0x01	; 1
    2770:	31 09       	sbc	r19, r1
    2772:	c2 17       	cp	r28, r18
    2774:	d3 07       	cpc	r29, r19
    2776:	0c f0       	brlt	.+2      	; 0x277a <select_file+0xb4>
    2778:	59 c0       	rjmp	.+178    	; 0x282c <select_file+0x166>
				selected++;
    277a:	21 96       	adiw	r28, 0x01	; 1
    277c:	ac 2e       	mov	r10, r28
    277e:	aa 0c       	add	r10, r10
    2780:	aa 0c       	add	r10, r10
    2782:	aa 0c       	add	r10, r10
			}
			break;
		default:
			break;
		}//switch
		while (keypad_read()!=255){__asm__ __volatile__("nop");}
    2784:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
    2788:	8f 3f       	cpi	r24, 0xFF	; 255
    278a:	89 f2       	breq	.-94     	; 0x272e <select_file+0x68>
    278c:	00 00       	nop
    278e:	fa cf       	rjmp	.-12     	; 0x2784 <select_file+0xbe>
	while (1){
		display_cursor(selected);
		key=wait_key();
		tone(key,6);
		display_cursor(selected);
		switch(key){
    2790:	1e 30       	cpi	r17, 0x0E	; 14
    2792:	f9 f0       	breq	.+62     	; 0x27d2 <select_file+0x10c>
    2794:	1f 30       	cpi	r17, 0x0F	; 15
    2796:	b1 f7       	brne	.-20     	; 0x2784 <select_file+0xbe>
			}else{
				selected=0;
			}
			break;
		case 15: // '#'
			if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
    2798:	e7 01       	movw	r28, r14
    279a:	21 96       	adiw	r28, 0x01	; 1
    279c:	9e 01       	movw	r18, r28
    279e:	22 0f       	add	r18, r18
    27a0:	33 1f       	adc	r19, r19
    27a2:	22 0f       	add	r18, r18
    27a4:	33 1f       	adc	r19, r19
    27a6:	22 0f       	add	r18, r18
    27a8:	33 1f       	adc	r19, r19
    27aa:	2c 15       	cp	r18, r12
    27ac:	3d 05       	cpc	r19, r13
    27ae:	0c f4       	brge	.+2      	; 0x27b2 <select_file+0xec>
    27b0:	53 c0       	rjmp	.+166    	; 0x2858 <select_file+0x192>
				page++;
				selected=0;
				cls();
				pg_lines=display_page(page);
			}else{
				selected=pg_lines-1;
    27b2:	cb 2d       	mov	r28, r11
    27b4:	d0 e0       	ldi	r29, 0x00	; 0
    27b6:	21 97       	sbiw	r28, 0x01	; 1
    27b8:	ac 2e       	mov	r10, r28
    27ba:	aa 0c       	add	r10, r10
    27bc:	aa 0c       	add	r10, r10
    27be:	aa 0c       	add	r10, r10
    27c0:	e1 cf       	rjmp	.-62     	; 0x2784 <select_file+0xbe>
			}
			break;	
		case 7: // UP_ARROW
			if (selected){
    27c2:	20 97       	sbiw	r28, 0x00	; 0
    27c4:	09 f1       	breq	.+66     	; 0x2808 <select_file+0x142>
				selected--;
    27c6:	21 97       	sbiw	r28, 0x01	; 1
    27c8:	ac 2e       	mov	r10, r28
    27ca:	aa 0c       	add	r10, r10
    27cc:	aa 0c       	add	r10, r10
    27ce:	aa 0c       	add	r10, r10
    27d0:	d9 cf       	rjmp	.-78     	; 0x2784 <select_file+0xbe>
		switch(key){
		case 10: // 'A'
			return page*DISPLAY_LINES+selected;
			break;
		case 14: // '*'
			if (page){
    27d2:	e1 14       	cp	r14, r1
    27d4:	f1 04       	cpc	r15, r1
    27d6:	e1 f4       	brne	.+56     	; 0x2810 <select_file+0x14a>
		case 9: // DOWN_ARROW
			if (selected<(pg_lines-1)){
				selected++;
			}else if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
				page++;
				selected=0;
    27d8:	c0 e0       	ldi	r28, 0x00	; 0
    27da:	d0 e0       	ldi	r29, 0x00	; 0
    27dc:	a1 2c       	mov	r10, r1
    27de:	d2 cf       	rjmp	.-92     	; 0x2784 <select_file+0xbe>
		key=wait_key();
		tone(key,6);
		display_cursor(selected);
		switch(key){
		case 10: // 'A'
			return page*DISPLAY_LINES+selected;
    27e0:	c7 01       	movw	r24, r14
    27e2:	88 0f       	add	r24, r24
    27e4:	99 1f       	adc	r25, r25
    27e6:	88 0f       	add	r24, r24
    27e8:	99 1f       	adc	r25, r25
    27ea:	88 0f       	add	r24, r24
    27ec:	99 1f       	adc	r25, r25
    27ee:	8c 0f       	add	r24, r28
    27f0:	9d 1f       	adc	r25, r29
		default:
			break;
		}//switch
		while (keypad_read()!=255){__asm__ __volatile__("nop");}
	}//while	
}
    27f2:	df 91       	pop	r29
    27f4:	cf 91       	pop	r28
    27f6:	1f 91       	pop	r17
    27f8:	0f 91       	pop	r16
    27fa:	ff 90       	pop	r15
    27fc:	ef 90       	pop	r14
    27fe:	df 90       	pop	r13
    2800:	cf 90       	pop	r12
    2802:	bf 90       	pop	r11
    2804:	af 90       	pop	r10
    2806:	08 95       	ret
			}
			break;	
		case 7: // UP_ARROW
			if (selected){
				selected--;
			}else if (page){
    2808:	e1 14       	cp	r14, r1
    280a:	f1 04       	cpc	r15, r1
    280c:	09 f4       	brne	.+2      	; 0x2810 <select_file+0x14a>
    280e:	ba cf       	rjmp	.-140    	; 0x2784 <select_file+0xbe>
				page--;
    2810:	81 e0       	ldi	r24, 0x01	; 1
    2812:	e8 1a       	sub	r14, r24
    2814:	f1 08       	sbc	r15, r1
				selected=7;
				cls();
    2816:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
				pg_lines=display_page(page);
    281a:	c7 01       	movw	r24, r14
    281c:	0e 94 29 13 	call	0x2652	; 0x2652 <display_page>
    2820:	b8 2e       	mov	r11, r24
		case 7: // UP_ARROW
			if (selected){
				selected--;
			}else if (page){
				page--;
				selected=7;
    2822:	c7 e0       	ldi	r28, 0x07	; 7
    2824:	d0 e0       	ldi	r29, 0x00	; 0
    2826:	58 e3       	ldi	r21, 0x38	; 56
    2828:	a5 2e       	mov	r10, r21
    282a:	ac cf       	rjmp	.-168    	; 0x2784 <select_file+0xbe>
			}
			break;
		case 9: // DOWN_ARROW
			if (selected<(pg_lines-1)){
				selected++;
			}else if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
    282c:	87 01       	movw	r16, r14
    282e:	0f 5f       	subi	r16, 0xFF	; 255
    2830:	1f 4f       	sbci	r17, 0xFF	; 255
    2832:	98 01       	movw	r18, r16
    2834:	22 0f       	add	r18, r18
    2836:	33 1f       	adc	r19, r19
    2838:	22 0f       	add	r18, r18
    283a:	33 1f       	adc	r19, r19
    283c:	22 0f       	add	r18, r18
    283e:	33 1f       	adc	r19, r19
    2840:	2c 15       	cp	r18, r12
    2842:	3d 05       	cpc	r19, r13
    2844:	0c f0       	brlt	.+2      	; 0x2848 <select_file+0x182>
    2846:	9e cf       	rjmp	.-196    	; 0x2784 <select_file+0xbe>
				page++;
				selected=0;
				cls();
    2848:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
				pg_lines=display_page(page);
    284c:	c8 01       	movw	r24, r16
    284e:	0e 94 29 13 	call	0x2652	; 0x2652 <display_page>
    2852:	b8 2e       	mov	r11, r24
			break;
		case 9: // DOWN_ARROW
			if (selected<(pg_lines-1)){
				selected++;
			}else if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
				page++;
    2854:	78 01       	movw	r14, r16
    2856:	c0 cf       	rjmp	.-128    	; 0x27d8 <select_file+0x112>
			break;
		case 15: // '#'
			if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
				page++;
				selected=0;
				cls();
    2858:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
				pg_lines=display_page(page);
    285c:	ce 01       	movw	r24, r28
    285e:	0e 94 29 13 	call	0x2652	; 0x2652 <display_page>
    2862:	b8 2e       	mov	r11, r24
				selected=0;
			}
			break;
		case 15: // '#'
			if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
				page++;
    2864:	7e 01       	movw	r14, r28
				selected=0;
    2866:	c0 e0       	ldi	r28, 0x00	; 0
    2868:	d0 e0       	ldi	r29, 0x00	; 0
    286a:	a1 2c       	mov	r10, r1
    286c:	8b cf       	rjmp	.-234    	; 0x2784 <select_file+0xbe>

0000286e <games_in_flash>:


// slection et excution
// d'un jeux qui est en
// mmoire flash
void games_in_flash(){
    286e:	af 92       	push	r10
    2870:	bf 92       	push	r11
    2872:	cf 92       	push	r12
    2874:	df 92       	push	r13
    2876:	ef 92       	push	r14
    2878:	ff 92       	push	r15
    287a:	0f 93       	push	r16
    287c:	1f 93       	push	r17
    287e:	cf 93       	push	r28
    2880:	df 93       	push	r29
    2882:	cd b7       	in	r28, 0x3d	; 61
    2884:	de b7       	in	r29, 0x3e	; 62
    2886:	a2 97       	sbiw	r28, 0x22	; 34
    2888:	0f b6       	in	r0, 0x3f	; 63
    288a:	f8 94       	cli
    288c:	de bf       	out	0x3e, r29	; 62
    288e:	0f be       	out	0x3f, r0	; 63
    2890:	cd bf       	out	0x3d, r28	; 61
	uint16_t i=0,j,entry=0,selected;
	uint8_t c, name[32];

	while ((c=pgm_read_byte(&flash_games[i++]))){
    2892:	ed e5       	ldi	r30, 0x5D	; 93
    2894:	f1 e0       	ldi	r31, 0x01	; 1
    2896:	94 91       	lpm	r25, Z
    2898:	99 23       	and	r25, r25
    289a:	09 f4       	brne	.+2      	; 0x289e <games_in_flash+0x30>
    289c:	77 c0       	rjmp	.+238    	; 0x298c <games_in_flash+0x11e>
    289e:	c1 2c       	mov	r12, r1
    28a0:	d1 2c       	mov	r13, r1

// slection et excution
// d'un jeux qui est en
// mmoire flash
void games_in_flash(){
	uint16_t i=0,j,entry=0,selected;
    28a2:	a1 2c       	mov	r10, r1
    28a4:	b1 2c       	mov	r11, r1
	uint8_t c, name[32];

	while ((c=pgm_read_byte(&flash_games[i++]))){
    28a6:	01 e0       	ldi	r16, 0x01	; 1
    28a8:	10 e0       	ldi	r17, 0x00	; 0
		j=0;
		while (c!='\n'){
    28aa:	9a 30       	cpi	r25, 0x0A	; 10
    28ac:	09 f4       	brne	.+2      	; 0x28b0 <games_in_flash+0x42>
    28ae:	67 c0       	rjmp	.+206    	; 0x297e <games_in_flash+0x110>
    28b0:	de 01       	movw	r26, r28
    28b2:	11 96       	adiw	r26, 0x01	; 1
    28b4:	20 e0       	ldi	r18, 0x00	; 0
    28b6:	30 e0       	ldi	r19, 0x00	; 0
			name[j++]=c;
    28b8:	2f 5f       	subi	r18, 0xFF	; 255
    28ba:	3f 4f       	sbci	r19, 0xFF	; 255
    28bc:	9d 93       	st	X+, r25
			c=pgm_read_byte(&flash_games[i++]);
    28be:	0f 5f       	subi	r16, 0xFF	; 255
    28c0:	1f 4f       	sbci	r17, 0xFF	; 255
    28c2:	c8 01       	movw	r24, r16
    28c4:	83 5a       	subi	r24, 0xA3	; 163
    28c6:	9e 4f       	sbci	r25, 0xFE	; 254
    28c8:	7c 01       	movw	r14, r24
    28ca:	fc 01       	movw	r30, r24
    28cc:	31 97       	sbiw	r30, 0x01	; 1
    28ce:	94 91       	lpm	r25, Z
	uint16_t i=0,j,entry=0,selected;
	uint8_t c, name[32];

	while ((c=pgm_read_byte(&flash_games[i++]))){
		j=0;
		while (c!='\n'){
    28d0:	9a 30       	cpi	r25, 0x0A	; 10
    28d2:	91 f7       	brne	.-28     	; 0x28b8 <games_in_flash+0x4a>
			name[j++]=c;
			c=pgm_read_byte(&flash_games[i++]);
		}
		name[j]=0;
    28d4:	e1 e0       	ldi	r30, 0x01	; 1
    28d6:	f0 e0       	ldi	r31, 0x00	; 0
    28d8:	ec 0f       	add	r30, r28
    28da:	fd 1f       	adc	r31, r29
    28dc:	e2 0f       	add	r30, r18
    28de:	f3 1f       	adc	r31, r19
    28e0:	10 82       	st	Z, r1
		sram_store_block(entry*ENTRY_SIZE,ENTRY_SIZE,name);
    28e2:	ae 01       	movw	r20, r28
    28e4:	4f 5f       	subi	r20, 0xFF	; 255
    28e6:	5f 4f       	sbci	r21, 0xFF	; 255
    28e8:	60 e2       	ldi	r22, 0x20	; 32
    28ea:	70 e0       	ldi	r23, 0x00	; 0
    28ec:	c6 01       	movw	r24, r12
    28ee:	0e 94 89 17 	call	0x2f12	; 0x2f12 <sram_store_block>
		entry++;
    28f2:	ff ef       	ldi	r31, 0xFF	; 255
    28f4:	af 1a       	sub	r10, r31
    28f6:	bf 0a       	sbc	r11, r31
// mmoire flash
void games_in_flash(){
	uint16_t i=0,j,entry=0,selected;
	uint8_t c, name[32];

	while ((c=pgm_read_byte(&flash_games[i++]))){
    28f8:	0f 5f       	subi	r16, 0xFF	; 255
    28fa:	1f 4f       	sbci	r17, 0xFF	; 255
    28fc:	f7 01       	movw	r30, r14
    28fe:	94 91       	lpm	r25, Z
    2900:	f0 e2       	ldi	r31, 0x20	; 32
    2902:	cf 0e       	add	r12, r31
    2904:	d1 1c       	adc	r13, r1
    2906:	91 11       	cpse	r25, r1
    2908:	d0 cf       	rjmp	.-96     	; 0x28aa <games_in_flash+0x3c>
    290a:	c5 01       	movw	r24, r10
		}
		name[j]=0;
		sram_store_block(entry*ENTRY_SIZE,ENTRY_SIZE,name);
		entry++;
	}
	cls();
    290c:	89 a3       	std	Y+33, r24	; 0x21
    290e:	9a a3       	std	Y+34, r25	; 0x22
    2910:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
	selected=select_file(entry);
    2914:	89 a1       	ldd	r24, Y+33	; 0x21
    2916:	9a a1       	ldd	r25, Y+34	; 0x22
    2918:	0e 94 63 13 	call	0x26c6	; 0x26c6 <select_file>
	switch(selected){
    291c:	00 97       	sbiw	r24, 0x00	; 0
    291e:	19 f1       	breq	.+70     	; 0x2966 <games_in_flash+0xf8>
    2920:	01 97       	sbiw	r24, 0x01	; 1
    2922:	81 f4       	brne	.+32     	; 0x2944 <games_in_flash+0xd6>
	case 0:
		load_flash_game(sokoban,SOKOBAN_SIZE);
		text_scroller(sokoban_info,4);
		break;
	case 1:
		load_flash_game(spacefig,SPACEFIG_SIZE);
    2924:	68 e1       	ldi	r22, 0x18	; 24
    2926:	7b e0       	ldi	r23, 0x0B	; 11
    2928:	8d ec       	ldi	r24, 0xCD	; 205
    292a:	9f e0       	ldi	r25, 0x0F	; 15
    292c:	0e 94 08 13 	call	0x2610	; 0x2610 <load_flash_game>
		text_scroller(spacefig_info,4);
    2930:	64 e0       	ldi	r22, 0x04	; 4
    2932:	88 ea       	ldi	r24, 0xA8	; 168
    2934:	9f e0       	ldi	r25, 0x0F	; 15
    2936:	0e 94 81 16 	call	0x2d02	; 0x2d02 <text_scroller>
		return;
		break;
	default:
		return;	
	}
	if (schip()){
    293a:	0e 94 77 11 	call	0x22ee	; 0x22ee <schip>
    293e:	81 11       	cpse	r24, r1
		print_vms();	
    2940:	0e 94 ee 12 	call	0x25dc	; 0x25dc <print_vms>
	}
}
    2944:	a2 96       	adiw	r28, 0x22	; 34
    2946:	0f b6       	in	r0, 0x3f	; 63
    2948:	f8 94       	cli
    294a:	de bf       	out	0x3e, r29	; 62
    294c:	0f be       	out	0x3f, r0	; 63
    294e:	cd bf       	out	0x3d, r28	; 61
    2950:	df 91       	pop	r29
    2952:	cf 91       	pop	r28
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	ef 90       	pop	r14
    295c:	df 90       	pop	r13
    295e:	cf 90       	pop	r12
    2960:	bf 90       	pop	r11
    2962:	af 90       	pop	r10
    2964:	08 95       	ret
	}
	cls();
	selected=select_file(entry);
	switch(selected){
	case 0:
		load_flash_game(sokoban,SOKOBAN_SIZE);
    2966:	60 e0       	ldi	r22, 0x00	; 0
    2968:	7e e0       	ldi	r23, 0x0E	; 14
    296a:	88 ea       	ldi	r24, 0xA8	; 168
    296c:	91 e0       	ldi	r25, 0x01	; 1
    296e:	0e 94 08 13 	call	0x2610	; 0x2610 <load_flash_game>
		text_scroller(sokoban_info,4);
    2972:	64 e0       	ldi	r22, 0x04	; 4
    2974:	87 e9       	ldi	r24, 0x97	; 151
    2976:	91 e0       	ldi	r25, 0x01	; 1
    2978:	0e 94 81 16 	call	0x2d02	; 0x2d02 <text_scroller>
		break;
    297c:	de cf       	rjmp	.-68     	; 0x293a <games_in_flash+0xcc>
	uint16_t i=0,j,entry=0,selected;
	uint8_t c, name[32];

	while ((c=pgm_read_byte(&flash_games[i++]))){
		j=0;
		while (c!='\n'){
    297e:	20 e0       	ldi	r18, 0x00	; 0
    2980:	30 e0       	ldi	r19, 0x00	; 0
    2982:	f8 01       	movw	r30, r16
    2984:	e3 5a       	subi	r30, 0xA3	; 163
    2986:	fe 4f       	sbci	r31, 0xFE	; 254
    2988:	7f 01       	movw	r14, r30
    298a:	a4 cf       	rjmp	.-184    	; 0x28d4 <games_in_flash+0x66>
// mmoire flash
void games_in_flash(){
	uint16_t i=0,j,entry=0,selected;
	uint8_t c, name[32];

	while ((c=pgm_read_byte(&flash_games[i++]))){
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	90 e0       	ldi	r25, 0x00	; 0
    2990:	bd cf       	rjmp	.-134    	; 0x290c <games_in_flash+0x9e>

00002992 <main>:
	

int main(void){
	uint8_t sdc_ok=0;
	
	CLKPR= (1<<7);
    2992:	80 e8       	ldi	r24, 0x80	; 128
    2994:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0 ; // dsactivation du diviseur
    2998:	10 92 61 00 	sts	0x0061, r1
	tvout_init();
    299c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <tvout_init>
	//initialisation SPI
	SPI_DDR |= SPI_CLK+SPI_MOSI;
    29a0:	84 b1       	in	r24, 0x04	; 4
    29a2:	88 62       	ori	r24, 0x28	; 40
    29a4:	84 b9       	out	0x04, r24	; 4
	SPI_CR = (1<<SPE)|(1<<MSTR);
    29a6:	80 e5       	ldi	r24, 0x50	; 80
    29a8:	8c bd       	out	0x2c, r24	; 44
	SPI_SR |= 1; // Fosc/2
    29aa:	8d b5       	in	r24, 0x2d	; 45
    29ac:	81 60       	ori	r24, 0x01	; 1
    29ae:	8d bd       	out	0x2d, r24	; 45
	//initialiation ADC
	ADMUX = (3<<5)|1;
    29b0:	81 e6       	ldi	r24, 0x61	; 97
    29b2:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = (1<<ADEN)|(1<<ADSC)|7;
    29b6:	87 ec       	ldi	r24, 0xC7	; 199
    29b8:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0;
    29bc:	10 92 7b 00 	sts	0x007B, r1
	DIDR0 = 1;
    29c0:	81 e0       	ldi	r24, 0x01	; 1
    29c2:	80 93 7e 00 	sts	0x007E, r24
	// initialisation du clavier hexadcimal
	keypad_init();
    29c6:	0e 94 ff 14 	call	0x29fe	; 0x29fe <keypad_init>
	// initialisation sons
	tone_init();
    29ca:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <tone_init>
	// initialisation mmoire SRAM
	sram_init();
    29ce:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <sram_init>
	sei();// activation des interruptions
    29d2:	78 94       	sei
	srand(TCNT1);
    29d4:	80 91 84 00 	lds	r24, 0x0084
    29d8:	90 91 85 00 	lds	r25, 0x0085
    29dc:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <srand>
#if SDC_SUPPORT
	//initialisation carte SD
	sd_raw_init();
	if (fs_mount()) sdc_ok=fs_open_dir("/");
#endif
	text_scroller(credits,4);
    29e0:	64 e0       	ldi	r22, 0x04	; 4
    29e2:	80 e0       	ldi	r24, 0x00	; 0
    29e4:	91 e0       	ldi	r25, 0x01	; 1
    29e6:	0e 94 81 16 	call	0x2d02	; 0x2d02 <text_scroller>
	while (1){
		sram_clear();
    29ea:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <sram_clear>
		cls();
    29ee:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>
		select_font(FONT_ASCII);
    29f2:	82 e0       	ldi	r24, 0x02	; 2
    29f4:	0e 94 75 15 	call	0x2aea	; 0x2aea <select_font>
		if (!sdc_ok){
			prt_pstr(PSTR("carte SD absente!"));
			new_line();
			prompt_key();
#endif
			games_in_flash();
    29f8:	0e 94 37 14 	call	0x286e	; 0x286e <games_in_flash>
    29fc:	f6 cf       	rjmp	.-20     	; 0x29ea <main+0x58>

000029fe <keypad_init>:

#include <avr/interrupt.h>


void keypad_init(){
	KP_DDR |= KP_OMASK; // broches en sortie
    29fe:	8a b1       	in	r24, 0x0a	; 10
    2a00:	8d 62       	ori	r24, 0x2D	; 45
    2a02:	8a b9       	out	0x0a, r24	; 10
	KP_OPORT |= KP_OMASK; // mettre les broches  1
    2a04:	8b b1       	in	r24, 0x0b	; 11
    2a06:	8d 62       	ori	r24, 0x2D	; 45
    2a08:	8b b9       	out	0x0b, r24	; 11
	KP_IPORT |= KP_IMASK; // activation pullup	sur les entres
    2a0a:	88 b1       	in	r24, 0x08	; 8
    2a0c:	8c 63       	ori	r24, 0x3C	; 60
    2a0e:	88 b9       	out	0x08, r24	; 8
    2a10:	08 95       	ret

00002a12 <keypad_read>:
	
PROGMEM const uint8_t outputs[4]={KP_OUT1,KP_OUT2,KP_OUT3,KP_OUT4};
PROGMEM const uint8_t inputs[4]={KP_INP5,KP_INP6,KP_INP7,KP_INP8};


uint8_t keypad_read(){
    2a12:	40 e0       	ldi	r20, 0x00	; 0
    2a14:	50 e0       	ldi	r21, 0x00	; 0
	register uint8_t r,c,key;
	register int16_t bounce=0;
    2a16:	20 e0       	ldi	r18, 0x00	; 0
    2a18:	30 e0       	ldi	r19, 0x00	; 0
	key=255;
	for (r=0;r<4;r++){
		KP_OPORT &= ~pgm_read_byte(&outputs[r]);
		for(c=0;c<4;c++){
			if (!(KP_PIN & pgm_read_byte(&inputs[c]))){
				frame_delay=2;
    2a1a:	a2 e0       	ldi	r26, 0x02	; 2
	register uint8_t r,c,key;
	register int16_t bounce=0;
	
	key=255;
	for (r=0;r<4;r++){
		KP_OPORT &= ~pgm_read_byte(&outputs[r]);
    2a1c:	8b b1       	in	r24, 0x0b	; 11
    2a1e:	fa 01       	movw	r30, r20
    2a20:	ed 57       	subi	r30, 0x7D	; 125
    2a22:	fe 4f       	sbci	r31, 0xFE	; 254
    2a24:	e4 91       	lpm	r30, Z
    2a26:	e0 95       	com	r30
    2a28:	e8 23       	and	r30, r24
    2a2a:	eb b9       	out	0x0b, r30	; 11
    2a2c:	80 e0       	ldi	r24, 0x00	; 0
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
		for(c=0;c<4;c++){
			if (!(KP_PIN & pgm_read_byte(&inputs[c]))){
    2a30:	76 b1       	in	r23, 0x06	; 6
    2a32:	fc 01       	movw	r30, r24
    2a34:	e1 58       	subi	r30, 0x81	; 129
    2a36:	fe 4f       	sbci	r31, 0xFE	; 254
    2a38:	64 91       	lpm	r22, Z
    2a3a:	67 23       	and	r22, r23
    2a3c:	a1 f4       	brne	.+40     	; 0x2a66 <keypad_read+0x54>
				frame_delay=2;
    2a3e:	a0 93 39 01 	sts	0x0139, r26
				while (frame_delay){
    2a42:	60 91 39 01 	lds	r22, 0x0139
    2a46:	66 23       	and	r22, r22
    2a48:	51 f0       	breq	.+20     	; 0x2a5e <keypad_read+0x4c>
				   if (!(KP_PIN & pgm_read_byte(&inputs[c]))) bounce++; else bounce--;				
    2a4a:	76 b1       	in	r23, 0x06	; 6
    2a4c:	64 91       	lpm	r22, Z
    2a4e:	67 23       	and	r22, r23
    2a50:	c1 f4       	brne	.+48     	; 0x2a82 <keypad_read+0x70>
    2a52:	2f 5f       	subi	r18, 0xFF	; 255
    2a54:	3f 4f       	sbci	r19, 0xFF	; 255
	for (r=0;r<4;r++){
		KP_OPORT &= ~pgm_read_byte(&outputs[r]);
		for(c=0;c<4;c++){
			if (!(KP_PIN & pgm_read_byte(&inputs[c]))){
				frame_delay=2;
				while (frame_delay){
    2a56:	60 91 39 01 	lds	r22, 0x0139
    2a5a:	61 11       	cpse	r22, r1
    2a5c:	f6 cf       	rjmp	.-20     	; 0x2a4a <keypad_read+0x38>
				   if (!(KP_PIN & pgm_read_byte(&inputs[c]))) bounce++; else bounce--;				
				}
				if (bounce>12000){
    2a5e:	21 3e       	cpi	r18, 0xE1	; 225
    2a60:	6e e2       	ldi	r22, 0x2E	; 46
    2a62:	36 07       	cpc	r19, r22
    2a64:	8c f4       	brge	.+34     	; 0x2a88 <keypad_read+0x76>
    2a66:	01 96       	adiw	r24, 0x01	; 1
	register int16_t bounce=0;
	
	key=255;
	for (r=0;r<4;r++){
		KP_OPORT &= ~pgm_read_byte(&outputs[r]);
		for(c=0;c<4;c++){
    2a68:	84 30       	cpi	r24, 0x04	; 4
    2a6a:	91 05       	cpc	r25, r1
    2a6c:	09 f7       	brne	.-62     	; 0x2a30 <keypad_read+0x1e>
					key=pgm_read_byte(&key_matrix[r][c]);
					break;
				}
			}
		}
		KP_OPORT |= KP_OMASK;
    2a6e:	8b b1       	in	r24, 0x0b	; 11
    2a70:	8d 62       	ori	r24, 0x2D	; 45
    2a72:	8b b9       	out	0x0b, r24	; 11
    2a74:	4f 5f       	subi	r20, 0xFF	; 255
    2a76:	5f 4f       	sbci	r21, 0xFF	; 255
uint8_t keypad_read(){
	register uint8_t r,c,key;
	register int16_t bounce=0;
	
	key=255;
	for (r=0;r<4;r++){
    2a78:	44 30       	cpi	r20, 0x04	; 4
    2a7a:	51 05       	cpc	r21, r1
    2a7c:	79 f6       	brne	.-98     	; 0x2a1c <keypad_read+0xa>
    2a7e:	8f ef       	ldi	r24, 0xFF	; 255
		}
		KP_OPORT |= KP_OMASK;
		if (key!=255) break;
	}
	return key;
};
    2a80:	08 95       	ret
		KP_OPORT &= ~pgm_read_byte(&outputs[r]);
		for(c=0;c<4;c++){
			if (!(KP_PIN & pgm_read_byte(&inputs[c]))){
				frame_delay=2;
				while (frame_delay){
				   if (!(KP_PIN & pgm_read_byte(&inputs[c]))) bounce++; else bounce--;				
    2a82:	21 50       	subi	r18, 0x01	; 1
    2a84:	31 09       	sbc	r19, r1
    2a86:	dd cf       	rjmp	.-70     	; 0x2a42 <keypad_read+0x30>
				}
				if (bounce>12000){
					key=pgm_read_byte(&key_matrix[r][c]);
    2a88:	fa 01       	movw	r30, r20
    2a8a:	ee 0f       	add	r30, r30
    2a8c:	ff 1f       	adc	r31, r31
    2a8e:	ee 0f       	add	r30, r30
    2a90:	ff 1f       	adc	r31, r31
    2a92:	e8 0f       	add	r30, r24
    2a94:	f9 1f       	adc	r31, r25
    2a96:	e9 57       	subi	r30, 0x79	; 121
    2a98:	fe 4f       	sbci	r31, 0xFE	; 254
    2a9a:	84 91       	lpm	r24, Z
					break;
				}
			}
		}
		KP_OPORT |= KP_OMASK;
    2a9c:	9b b1       	in	r25, 0x0b	; 11
    2a9e:	9d 62       	ori	r25, 0x2D	; 45
    2aa0:	9b b9       	out	0x0b, r25	; 11
		if (key!=255) break;
    2aa2:	8f 3f       	cpi	r24, 0xFF	; 255
    2aa4:	39 f3       	breq	.-50     	; 0x2a74 <keypad_read+0x62>
	}
	return key;
};
    2aa6:	08 95       	ret

00002aa8 <wait_key>:

uint8_t wait_key(){
	uint8_t key;
	while ((key=keypad_read())==255);
    2aa8:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
    2aac:	8f 3f       	cpi	r24, 0xFF	; 255
    2aae:	e1 f3       	breq	.-8      	; 0x2aa8 <wait_key>
	return key;	
}
    2ab0:	08 95       	ret

00002ab2 <prompt_key>:

void prompt_key(){
	uint8_t key;
	select_font(FONT_ASCII);
    2ab2:	82 e0       	ldi	r24, 0x02	; 2
    2ab4:	0e 94 75 15 	call	0x2aea	; 0x2aea <select_font>
	while (keypad_read()!=255);
    2ab8:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
    2abc:	8f 3f       	cpi	r24, 0xFF	; 255
    2abe:	e1 f7       	brne	.-8      	; 0x2ab8 <prompt_key+0x6>
	prt_pstr(PSTR("une touche..."));
    2ac0:	81 e7       	ldi	r24, 0x71	; 113
    2ac2:	91 e0       	ldi	r25, 0x01	; 1
    2ac4:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <prt_pstr>
	return key;
};

uint8_t wait_key(){
	uint8_t key;
	while ((key=keypad_read())==255);
    2ac8:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
    2acc:	8f 3f       	cpi	r24, 0xFF	; 255
    2ace:	e1 f3       	breq	.-8      	; 0x2ac8 <prompt_key+0x16>
	uint8_t key;
	select_font(FONT_ASCII);
	while (keypad_read()!=255);
	prt_pstr(PSTR("une touche..."));
	wait_key();
	while ((key=keypad_read())!=255) tone(key,4);
    2ad0:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
    2ad4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ad6:	41 f0       	breq	.+16     	; 0x2ae8 <prompt_key+0x36>
    2ad8:	64 e0       	ldi	r22, 0x04	; 4
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <tone>
    2ae0:	0e 94 09 15 	call	0x2a12	; 0x2a12 <keypad_read>
    2ae4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ae6:	c1 f7       	brne	.-16     	; 0x2ad8 <prompt_key+0x26>
}
    2ae8:	08 95       	ret

00002aea <select_font>:

uint8_t font=FONT_ASCII;
uint8_t xpos=0, ypos=0;
	
void select_font(uint8_t font_id){
	font=font_id;
    2aea:	80 93 04 01 	sts	0x0104, r24
    2aee:	08 95       	ret

00002af0 <new_line>:
}

void new_line(){
	xpos=0;
    2af0:	10 92 33 01 	sts	0x0133, r1
	switch (font){
    2af4:	80 91 04 01 	lds	r24, 0x0104
    2af8:	81 30       	cpi	r24, 0x01	; 1
    2afa:	c1 f0       	breq	.+48     	; 0x2b2c <new_line+0x3c>
    2afc:	68 f0       	brcs	.+26     	; 0x2b18 <new_line+0x28>
    2afe:	82 30       	cpi	r24, 0x02	; 2
    2b00:	51 f4       	brne	.+20     	; 0x2b16 <new_line+0x26>
		}else{
			scroll_up(LHEX_HEIGHT);
		}
		break;
	case FONT_ASCII:
		if ((ypos+CHAR_HEIGHT)<=(VRES-CHAR_HEIGHT+1)){
    2b02:	20 91 32 01 	lds	r18, 0x0132
    2b06:	82 2f       	mov	r24, r18
    2b08:	90 e0       	ldi	r25, 0x00	; 0
    2b0a:	c2 97       	sbiw	r24, 0x32	; 50
    2b0c:	cc f4       	brge	.+50     	; 0x2b40 <new_line+0x50>
			ypos+=CHAR_HEIGHT;
    2b0e:	28 5f       	subi	r18, 0xF8	; 248
    2b10:	20 93 32 01 	sts	0x0132, r18
    2b14:	08 95       	ret
    2b16:	08 95       	ret

void new_line(){
	xpos=0;
	switch (font){
	case FONT_SHEX:
		if ((ypos+SHEX_HEIGHT)<=(VRES-SHEX_HEIGHT+1)){
    2b18:	20 91 32 01 	lds	r18, 0x0132
    2b1c:	82 2f       	mov	r24, r18
    2b1e:	90 e0       	ldi	r25, 0x00	; 0
    2b20:	c6 97       	sbiw	r24, 0x36	; 54
    2b22:	a4 f4       	brge	.+40     	; 0x2b4c <new_line+0x5c>
			ypos+=SHEX_HEIGHT;
    2b24:	2a 5f       	subi	r18, 0xFA	; 250
    2b26:	20 93 32 01 	sts	0x0132, r18
    2b2a:	08 95       	ret
		}else{
			scroll_up(SHEX_HEIGHT);
		}
		break;
	case FONT_LHEX:
		if ((ypos+LHEX_HEIGHT)<=(VRES-LHEX_HEIGHT+1)){
    2b2c:	20 91 32 01 	lds	r18, 0x0132
    2b30:	82 2f       	mov	r24, r18
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	8e 97       	sbiw	r24, 0x2e	; 46
    2b36:	3c f4       	brge	.+14     	; 0x2b46 <new_line+0x56>
			ypos+=LHEX_HEIGHT;
    2b38:	26 5f       	subi	r18, 0xF6	; 246
    2b3a:	20 93 32 01 	sts	0x0132, r18
    2b3e:	08 95       	ret
		break;
	case FONT_ASCII:
		if ((ypos+CHAR_HEIGHT)<=(VRES-CHAR_HEIGHT+1)){
			ypos+=CHAR_HEIGHT;
		}else{
			scroll_up(CHAR_HEIGHT);
    2b40:	88 e0       	ldi	r24, 0x08	; 8
    2b42:	0c 94 74 19 	jmp	0x32e8	; 0x32e8 <scroll_up>
		break;
	case FONT_LHEX:
		if ((ypos+LHEX_HEIGHT)<=(VRES-LHEX_HEIGHT+1)){
			ypos+=LHEX_HEIGHT;
		}else{
			scroll_up(LHEX_HEIGHT);
    2b46:	8a e0       	ldi	r24, 0x0A	; 10
    2b48:	0c 94 74 19 	jmp	0x32e8	; 0x32e8 <scroll_up>
	switch (font){
	case FONT_SHEX:
		if ((ypos+SHEX_HEIGHT)<=(VRES-SHEX_HEIGHT+1)){
			ypos+=SHEX_HEIGHT;
		}else{
			scroll_up(SHEX_HEIGHT);
    2b4c:	86 e0       	ldi	r24, 0x06	; 6
    2b4e:	0c 94 74 19 	jmp	0x32e8	; 0x32e8 <scroll_up>

00002b52 <put_char>:
		break;	
	}//swtich

}

void put_char(uint8_t c){
    2b52:	0f 93       	push	r16
	switch(font){
    2b54:	90 91 04 01 	lds	r25, 0x0104
    2b58:	91 30       	cpi	r25, 0x01	; 1
    2b5a:	29 f1       	breq	.+74     	; 0x2ba6 <put_char+0x54>
    2b5c:	50 f0       	brcs	.+20     	; 0x2b72 <put_char+0x20>
    2b5e:	92 30       	cpi	r25, 0x02	; 2
    2b60:	31 f4       	brne	.+12     	; 0x2b6e <put_char+0x1c>
				new_line();
			}
		}
		break;
	case FONT_ASCII:
		if (c=='\n'){
    2b62:	8a 30       	cpi	r24, 0x0A	; 10
    2b64:	e9 f0       	breq	.+58     	; 0x2ba0 <put_char+0x4e>
			new_line();
		}else if ((c>31) && (c<(FONT_SIZE+32))){
    2b66:	90 ee       	ldi	r25, 0xE0	; 224
    2b68:	98 0f       	add	r25, r24
    2b6a:	95 36       	cpi	r25, 0x65	; 101
    2b6c:	a0 f1       	brcs	.+104    	; 0x2bd6 <put_char+0x84>
				new_line();
			}
		}
		break;		
	}
}
    2b6e:	0f 91       	pop	r16
    2b70:	08 95       	ret
}

void put_char(uint8_t c){
	switch(font){
	case FONT_SHEX:	
		if (c<16){
    2b72:	80 31       	cpi	r24, 0x10	; 16
    2b74:	e0 f7       	brcc	.-8      	; 0x2b6e <put_char+0x1c>
			put_sprite(xpos,ypos,SHEX_HEIGHT,&font_hex_4x6[c*SHEX_HEIGHT],FLASH_MEM);
    2b76:	96 e0       	ldi	r25, 0x06	; 6
    2b78:	89 9f       	mul	r24, r25
    2b7a:	90 01       	movw	r18, r0
    2b7c:	11 24       	eor	r1, r1
    2b7e:	23 55       	subi	r18, 0x53	; 83
    2b80:	31 4e       	sbci	r19, 0xE1	; 225
    2b82:	00 e0       	ldi	r16, 0x00	; 0
    2b84:	46 e0       	ldi	r20, 0x06	; 6
    2b86:	60 91 32 01 	lds	r22, 0x0132
    2b8a:	80 91 33 01 	lds	r24, 0x0133
    2b8e:	0e 94 e7 17 	call	0x2fce	; 0x2fce <put_sprite>
			xpos+=SHEX_WIDTH;
    2b92:	80 91 33 01 	lds	r24, 0x0133
    2b96:	8c 5f       	subi	r24, 0xFC	; 252
    2b98:	80 93 33 01 	sts	0x0133, r24
			if (xpos>(HRES-SHEX_WIDTH+1)){
    2b9c:	8e 37       	cpi	r24, 0x7E	; 126
    2b9e:	38 f3       	brcs	.-50     	; 0x2b6e <put_char+0x1c>
				new_line();
			}
		}
		break;		
	}
}
    2ba0:	0f 91       	pop	r16
	case FONT_SHEX:	
		if (c<16){
			put_sprite(xpos,ypos,SHEX_HEIGHT,&font_hex_4x6[c*SHEX_HEIGHT],FLASH_MEM);
			xpos+=SHEX_WIDTH;
			if (xpos>(HRES-SHEX_WIDTH+1)){
				new_line();
    2ba2:	0c 94 78 15 	jmp	0x2af0	; 0x2af0 <new_line>
			}
		}
		break;
	case FONT_LHEX:
		if (c<16){
    2ba6:	80 31       	cpi	r24, 0x10	; 16
    2ba8:	10 f7       	brcc	.-60     	; 0x2b6e <put_char+0x1c>
			put_sprite(xpos,ypos,LHEX_HEIGHT,&font_hex_8x10[c*LHEX_HEIGHT],FLASH_MEM);
    2baa:	9a e0       	ldi	r25, 0x0A	; 10
    2bac:	89 9f       	mul	r24, r25
    2bae:	90 01       	movw	r18, r0
    2bb0:	11 24       	eor	r1, r1
    2bb2:	23 5f       	subi	r18, 0xF3	; 243
    2bb4:	31 4e       	sbci	r19, 0xE1	; 225
    2bb6:	00 e0       	ldi	r16, 0x00	; 0
    2bb8:	4a e0       	ldi	r20, 0x0A	; 10
    2bba:	60 91 32 01 	lds	r22, 0x0132
    2bbe:	80 91 33 01 	lds	r24, 0x0133
    2bc2:	0e 94 e7 17 	call	0x2fce	; 0x2fce <put_sprite>
			xpos+=LHEX_WIDTH;
    2bc6:	80 91 33 01 	lds	r24, 0x0133
    2bca:	88 5f       	subi	r24, 0xF8	; 248
    2bcc:	80 93 33 01 	sts	0x0133, r24
			if (xpos>(HRES-LHEX_WIDTH+1)){
    2bd0:	8a 37       	cpi	r24, 0x7A	; 122
    2bd2:	68 f2       	brcs	.-102    	; 0x2b6e <put_char+0x1c>
    2bd4:	e5 cf       	rjmp	.-54     	; 0x2ba0 <put_char+0x4e>
		break;
	case FONT_ASCII:
		if (c=='\n'){
			new_line();
		}else if ((c>31) && (c<(FONT_SIZE+32))){
			put_sprite(xpos,ypos,CHAR_HEIGHT,&font_6x8[(c-32)*CHAR_HEIGHT],FLASH_MEM);
    2bd6:	28 2f       	mov	r18, r24
    2bd8:	30 e0       	ldi	r19, 0x00	; 0
    2bda:	22 0f       	add	r18, r18
    2bdc:	33 1f       	adc	r19, r19
    2bde:	22 0f       	add	r18, r18
    2be0:	33 1f       	adc	r19, r19
    2be2:	22 0f       	add	r18, r18
    2be4:	33 1f       	adc	r19, r19
    2be6:	2b 51       	subi	r18, 0x1B	; 27
    2be8:	36 4e       	sbci	r19, 0xE6	; 230
    2bea:	00 e0       	ldi	r16, 0x00	; 0
    2bec:	48 e0       	ldi	r20, 0x08	; 8
    2bee:	60 91 32 01 	lds	r22, 0x0132
    2bf2:	80 91 33 01 	lds	r24, 0x0133
    2bf6:	0e 94 e7 17 	call	0x2fce	; 0x2fce <put_sprite>
			xpos+=CHAR_WIDTH;
    2bfa:	80 91 33 01 	lds	r24, 0x0133
    2bfe:	8a 5f       	subi	r24, 0xFA	; 250
    2c00:	80 93 33 01 	sts	0x0133, r24
			if (xpos>(HRES-CHAR_WIDTH+1)){
    2c04:	8c 37       	cpi	r24, 0x7C	; 124
    2c06:	08 f4       	brcc	.+2      	; 0x2c0a <put_char+0xb8>
    2c08:	b2 cf       	rjmp	.-156    	; 0x2b6e <put_char+0x1c>
    2c0a:	ca cf       	rjmp	.-108    	; 0x2ba0 <put_char+0x4e>

00002c0c <set_cursor>:
		break;		
	}
}

void set_cursor(uint8_t x, uint8_t y){
	xpos=x;
    2c0c:	80 93 33 01 	sts	0x0133, r24
	ypos=y;
    2c10:	60 93 32 01 	sts	0x0132, r22
    2c14:	08 95       	ret

00002c16 <print>:

uint16_t get_cursor(){
	return (xpos<<8)+ypos;
}

void print(const unsigned char* str){
    2c16:	cf 93       	push	r28
    2c18:	df 93       	push	r29
    2c1a:	ec 01       	movw	r28, r24
	while (*str) put_char(*str++);
    2c1c:	88 81       	ld	r24, Y
    2c1e:	88 23       	and	r24, r24
    2c20:	31 f0       	breq	.+12     	; 0x2c2e <print+0x18>
    2c22:	21 96       	adiw	r28, 0x01	; 1
    2c24:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <put_char>
    2c28:	89 91       	ld	r24, Y+
    2c2a:	81 11       	cpse	r24, r1
    2c2c:	fb cf       	rjmp	.-10     	; 0x2c24 <print+0xe>
}
    2c2e:	df 91       	pop	r29
    2c30:	cf 91       	pop	r28
    2c32:	08 95       	ret

00002c34 <prt_pstr>:

void prt_pstr(const char *str){
    2c34:	cf 93       	push	r28
    2c36:	df 93       	push	r29
	uint8_t c;
	while ((c=pgm_read_byte(str++))) put_char(c);	
    2c38:	ec 01       	movw	r28, r24
    2c3a:	21 96       	adiw	r28, 0x01	; 1
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	84 91       	lpm	r24, Z
    2c40:	88 23       	and	r24, r24
    2c42:	39 f0       	breq	.+14     	; 0x2c52 <prt_pstr+0x1e>
    2c44:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <put_char>
    2c48:	fe 01       	movw	r30, r28
    2c4a:	84 91       	lpm	r24, Z
    2c4c:	21 96       	adiw	r28, 0x01	; 1
    2c4e:	81 11       	cpse	r24, r1
    2c50:	f9 cf       	rjmp	.-14     	; 0x2c44 <prt_pstr+0x10>
}
    2c52:	df 91       	pop	r29
    2c54:	cf 91       	pop	r28
    2c56:	08 95       	ret

00002c58 <print_hex>:
	put_char(' ');
	i++;
	while (i<12) put_char(nstr[i++]);
}

void print_hex(uint16_t n,uint8_t width){
    2c58:	1f 93       	push	r17
    2c5a:	cf 93       	push	r28
    2c5c:	df 93       	push	r29
    2c5e:	00 d0       	rcall	.+0      	; 0x2c60 <print_hex+0x8>
    2c60:	00 d0       	rcall	.+0      	; 0x2c62 <print_hex+0xa>
    2c62:	1f 92       	push	r1
    2c64:	cd b7       	in	r28, 0x3d	; 61
    2c66:	de b7       	in	r29, 0x3e	; 62
	uint8_t hex[4];
	uint8_t i=3,h;
    2c68:	13 e0       	ldi	r17, 0x03	; 3
    2c6a:	0c c0       	rjmp	.+24     	; 0x2c84 <print_hex+0x2c>
	
	do{
		h=n&0xf;
		if (h<10) hex[i]=h+'0'; else hex[i]=h+'A'-10;
    2c6c:	20 5d       	subi	r18, 0xD0	; 208
    2c6e:	20 83       	st	Z, r18
		n>>=4;
    2c70:	92 95       	swap	r25
    2c72:	82 95       	swap	r24
    2c74:	8f 70       	andi	r24, 0x0F	; 15
    2c76:	89 27       	eor	r24, r25
    2c78:	9f 70       	andi	r25, 0x0F	; 15
    2c7a:	89 27       	eor	r24, r25
		i--;
    2c7c:	11 50       	subi	r17, 0x01	; 1
		width--;
    2c7e:	61 50       	subi	r22, 0x01	; 1
	}while (n);
    2c80:	00 97       	sbiw	r24, 0x00	; 0
    2c82:	69 f0       	breq	.+26     	; 0x2c9e <print_hex+0x46>
void print_hex(uint16_t n,uint8_t width){
	uint8_t hex[4];
	uint8_t i=3,h;
	
	do{
		h=n&0xf;
    2c84:	28 2f       	mov	r18, r24
    2c86:	2f 70       	andi	r18, 0x0F	; 15
		if (h<10) hex[i]=h+'0'; else hex[i]=h+'A'-10;
    2c88:	e1 e0       	ldi	r30, 0x01	; 1
    2c8a:	f0 e0       	ldi	r31, 0x00	; 0
    2c8c:	ec 0f       	add	r30, r28
    2c8e:	fd 1f       	adc	r31, r29
    2c90:	e1 0f       	add	r30, r17
    2c92:	f1 1d       	adc	r31, r1
    2c94:	2a 30       	cpi	r18, 0x0A	; 10
    2c96:	50 f3       	brcs	.-44     	; 0x2c6c <print_hex+0x14>
    2c98:	29 5c       	subi	r18, 0xC9	; 201
    2c9a:	20 83       	st	Z, r18
    2c9c:	e9 cf       	rjmp	.-46     	; 0x2c70 <print_hex+0x18>
		n>>=4;
		i--;
		width--;
	}while (n);
	put_char(' ');
    2c9e:	80 e2       	ldi	r24, 0x20	; 32
    2ca0:	6d 83       	std	Y+5, r22	; 0x05
    2ca2:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <put_char>
	while (width){hex[i--]='0'; width--;}
    2ca6:	6d 81       	ldd	r22, Y+5	; 0x05
    2ca8:	81 2f       	mov	r24, r17
    2caa:	66 23       	and	r22, r22
    2cac:	79 f0       	breq	.+30     	; 0x2ccc <print_hex+0x74>
    2cae:	86 1b       	sub	r24, r22
    2cb0:	20 e3       	ldi	r18, 0x30	; 48
    2cb2:	01 c0       	rjmp	.+2      	; 0x2cb6 <print_hex+0x5e>
    2cb4:	19 2f       	mov	r17, r25
    2cb6:	9f ef       	ldi	r25, 0xFF	; 255
    2cb8:	91 0f       	add	r25, r17
    2cba:	e1 e0       	ldi	r30, 0x01	; 1
    2cbc:	f0 e0       	ldi	r31, 0x00	; 0
    2cbe:	ec 0f       	add	r30, r28
    2cc0:	fd 1f       	adc	r31, r29
    2cc2:	e1 0f       	add	r30, r17
    2cc4:	f1 1d       	adc	r31, r1
    2cc6:	20 83       	st	Z, r18
    2cc8:	98 13       	cpse	r25, r24
    2cca:	f4 cf       	rjmp	.-24     	; 0x2cb4 <print_hex+0x5c>
	i++;
    2ccc:	8f 5f       	subi	r24, 0xFF	; 255
	while (i<4) put_char(hex[i++]);
    2cce:	84 30       	cpi	r24, 0x04	; 4
    2cd0:	10 f0       	brcs	.+4      	; 0x2cd6 <print_hex+0x7e>
    2cd2:	0e c0       	rjmp	.+28     	; 0x2cf0 <print_hex+0x98>
    2cd4:	81 2f       	mov	r24, r17
    2cd6:	11 e0       	ldi	r17, 0x01	; 1
    2cd8:	18 0f       	add	r17, r24
    2cda:	e1 e0       	ldi	r30, 0x01	; 1
    2cdc:	f0 e0       	ldi	r31, 0x00	; 0
    2cde:	ec 0f       	add	r30, r28
    2ce0:	fd 1f       	adc	r31, r29
    2ce2:	e8 0f       	add	r30, r24
    2ce4:	f1 1d       	adc	r31, r1
    2ce6:	80 81       	ld	r24, Z
    2ce8:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <put_char>
    2cec:	14 30       	cpi	r17, 0x04	; 4
    2cee:	91 f7       	brne	.-28     	; 0x2cd4 <print_hex+0x7c>
}
    2cf0:	0f 90       	pop	r0
    2cf2:	0f 90       	pop	r0
    2cf4:	0f 90       	pop	r0
    2cf6:	0f 90       	pop	r0
    2cf8:	0f 90       	pop	r0
    2cfa:	df 91       	pop	r29
    2cfc:	cf 91       	pop	r28
    2cfe:	1f 91       	pop	r17
    2d00:	08 95       	ret

00002d02 <text_scroller>:
		if (xpos-CHAR_WIDTH>=0) xpos-=CHAR_WIDTH;
		break;	
	}
}

void text_scroller(const uint8_t *text, uint8_t speed){
    2d02:	ef 92       	push	r14
    2d04:	ff 92       	push	r15
    2d06:	0f 93       	push	r16
    2d08:	1f 93       	push	r17
    2d0a:	cf 93       	push	r28
    2d0c:	df 93       	push	r29
    2d0e:	7c 01       	movw	r14, r24
    2d10:	06 2f       	mov	r16, r22
	uint8_t c, j;

	cls();
    2d12:	0e 94 3c 19 	call	0x3278	; 0x3278 <cls>

uint8_t font=FONT_ASCII;
uint8_t xpos=0, ypos=0;
	
void select_font(uint8_t font_id){
	font=font_id;
    2d16:	22 e0       	ldi	r18, 0x02	; 2
    2d18:	20 93 04 01 	sts	0x0104, r18
void text_scroller(const uint8_t *text, uint8_t speed){
	uint8_t c, j;

	cls();
	select_font(FONT_ASCII);
	c=pgm_read_byte(text++);
    2d1c:	e7 01       	movw	r28, r14
    2d1e:	21 96       	adiw	r28, 0x01	; 1
    2d20:	f7 01       	movw	r30, r14
    2d22:	84 91       	lpm	r24, Z
	while (c){
    2d24:	88 23       	and	r24, r24
    2d26:	29 f1       	breq	.+74     	; 0x2d72 <text_scroller+0x70>
	}
}

void set_cursor(uint8_t x, uint8_t y){
	xpos=x;
	ypos=y;
    2d28:	a0 e2       	ldi	r26, 0x20	; 32
    2d2a:	fa 2e       	mov	r15, r26
		break;		
	}
}

void set_cursor(uint8_t x, uint8_t y){
	xpos=x;
    2d2c:	10 92 33 01 	sts	0x0133, r1
	ypos=y;
    2d30:	f0 92 32 01 	sts	0x0132, r15
	cls();
	select_font(FONT_ASCII);
	c=pgm_read_byte(text++);
	while (c){
		set_cursor(0,4*CHAR_HEIGHT);
		while (c && c!='\n'){
    2d34:	8a 30       	cpi	r24, 0x0A	; 10
    2d36:	41 f0       	breq	.+16     	; 0x2d48 <text_scroller+0x46>
			put_char(c);
    2d38:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <put_char>
			c=pgm_read_byte(text++);
    2d3c:	21 96       	adiw	r28, 0x01	; 1
    2d3e:	fe 01       	movw	r30, r28
    2d40:	31 97       	sbiw	r30, 0x01	; 1
    2d42:	84 91       	lpm	r24, Z
	cls();
	select_font(FONT_ASCII);
	c=pgm_read_byte(text++);
	while (c){
		set_cursor(0,4*CHAR_HEIGHT);
		while (c && c!='\n'){
    2d44:	81 11       	cpse	r24, r1
    2d46:	f6 cf       	rjmp	.-20     	; 0x2d34 <text_scroller+0x32>
		for (j=0;j<CHAR_HEIGHT;j++){
			frame_delay=speed;
			while(frame_delay);
			scroll_up(1);
		}
		c=pgm_read_byte(text++);
    2d48:	18 e0       	ldi	r17, 0x08	; 8
		while (c && c!='\n'){
			put_char(c);
			c=pgm_read_byte(text++);
		}
		for (j=0;j<CHAR_HEIGHT;j++){
			frame_delay=speed;
    2d4a:	00 93 39 01 	sts	0x0139, r16
			while(frame_delay);
    2d4e:	80 91 39 01 	lds	r24, 0x0139
    2d52:	81 11       	cpse	r24, r1
    2d54:	fc cf       	rjmp	.-8      	; 0x2d4e <text_scroller+0x4c>
			scroll_up(1);
    2d56:	81 e0       	ldi	r24, 0x01	; 1
    2d58:	0e 94 74 19 	call	0x32e8	; 0x32e8 <scroll_up>
    2d5c:	11 50       	subi	r17, 0x01	; 1
		set_cursor(0,4*CHAR_HEIGHT);
		while (c && c!='\n'){
			put_char(c);
			c=pgm_read_byte(text++);
		}
		for (j=0;j<CHAR_HEIGHT;j++){
    2d5e:	a9 f7       	brne	.-22     	; 0x2d4a <text_scroller+0x48>
			frame_delay=speed;
			while(frame_delay);
			scroll_up(1);
		}
		c=pgm_read_byte(text++);
    2d60:	9e 01       	movw	r18, r28
    2d62:	2f 5f       	subi	r18, 0xFF	; 255
    2d64:	3f 4f       	sbci	r19, 0xFF	; 255
    2d66:	fe 01       	movw	r30, r28
    2d68:	84 91       	lpm	r24, Z
	uint8_t c, j;

	cls();
	select_font(FONT_ASCII);
	c=pgm_read_byte(text++);
	while (c){
    2d6a:	88 23       	and	r24, r24
    2d6c:	11 f0       	breq	.+4      	; 0x2d72 <text_scroller+0x70>
		for (j=0;j<CHAR_HEIGHT;j++){
			frame_delay=speed;
			while(frame_delay);
			scroll_up(1);
		}
		c=pgm_read_byte(text++);
    2d6e:	e9 01       	movw	r28, r18
    2d70:	dd cf       	rjmp	.-70     	; 0x2d2c <text_scroller+0x2a>
    2d72:	d4 e0       	ldi	r29, 0x04	; 4
    2d74:	c8 e0       	ldi	r28, 0x08	; 8
	}
	for (c=0;c<4;c++){
		for (j=0;j<CHAR_HEIGHT;j++){
			frame_delay=speed;
    2d76:	00 93 39 01 	sts	0x0139, r16
			while(frame_delay);
    2d7a:	80 91 39 01 	lds	r24, 0x0139
    2d7e:	81 11       	cpse	r24, r1
    2d80:	fc cf       	rjmp	.-8      	; 0x2d7a <text_scroller+0x78>
			scroll_up(1);
    2d82:	81 e0       	ldi	r24, 0x01	; 1
    2d84:	0e 94 74 19 	call	0x32e8	; 0x32e8 <scroll_up>
    2d88:	c1 50       	subi	r28, 0x01	; 1
			scroll_up(1);
		}
		c=pgm_read_byte(text++);
	}
	for (c=0;c<4;c++){
		for (j=0;j<CHAR_HEIGHT;j++){
    2d8a:	a9 f7       	brne	.-22     	; 0x2d76 <text_scroller+0x74>
    2d8c:	d1 50       	subi	r29, 0x01	; 1
			while(frame_delay);
			scroll_up(1);
		}
		c=pgm_read_byte(text++);
	}
	for (c=0;c<4;c++){
    2d8e:	91 f7       	brne	.-28     	; 0x2d74 <text_scroller+0x72>
			frame_delay=speed;
			while(frame_delay);
			scroll_up(1);
		}
	}
}
    2d90:	df 91       	pop	r29
    2d92:	cf 91       	pop	r28
    2d94:	1f 91       	pop	r17
    2d96:	0f 91       	pop	r16
    2d98:	ff 90       	pop	r15
    2d9a:	ef 90       	pop	r14
    2d9c:	08 95       	ret

00002d9e <sram_wrmode>:
		--size;
	}
}

void sram_wrmode(unsigned char mode){
	sram_enable();
    2d9e:	40 98       	cbi	0x08, 0	; 8
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2da0:	9d b5       	in	r25, 0x2d	; 45
    2da2:	91 60       	ori	r25, 0x01	; 1
    2da4:	9d bd       	out	0x2d, r25	; 45
	SPI_DR = b;
    2da6:	91 e0       	ldi	r25, 0x01	; 1
    2da8:	9e bd       	out	0x2e, r25	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2daa:	0d b4       	in	r0, 0x2d	; 45
    2dac:	07 fe       	sbrs	r0, 7
    2dae:	fd cf       	rjmp	.-6      	; 0x2daa <sram_wrmode+0xc>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2db0:	9d b5       	in	r25, 0x2d	; 45
    2db2:	91 60       	ori	r25, 0x01	; 1
    2db4:	9d bd       	out	0x2d, r25	; 45
	SPI_DR = b;
    2db6:	8e bd       	out	0x2e, r24	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2db8:	0d b4       	in	r0, 0x2d	; 45
    2dba:	07 fe       	sbrs	r0, 7
    2dbc:	fd cf       	rjmp	.-6      	; 0x2db8 <sram_wrmode+0x1a>

void sram_wrmode(unsigned char mode){
	sram_enable();
	sram_send_byte(SRAM_WRMR);
	sram_send_byte(mode);
	sram_disable();
    2dbe:	40 9a       	sbi	0x08, 0	; 8
    2dc0:	08 95       	ret

00002dc2 <sram_clear>:
}

void sram_clear(){
	uint32_t i;

	sram_enable();
    2dc2:	40 98       	cbi	0x08, 0	; 8
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2dc4:	8d b5       	in	r24, 0x2d	; 45
    2dc6:	81 60       	ori	r24, 0x01	; 1
    2dc8:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2dca:	82 e0       	ldi	r24, 0x02	; 2
    2dcc:	8e bd       	out	0x2e, r24	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2dce:	0d b4       	in	r0, 0x2d	; 45
    2dd0:	07 fe       	sbrs	r0, 7
    2dd2:	fd cf       	rjmp	.-6      	; 0x2dce <sram_clear+0xc>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2dd4:	8d b5       	in	r24, 0x2d	; 45
    2dd6:	81 60       	ori	r24, 0x01	; 1
    2dd8:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2dda:	1e bc       	out	0x2e, r1	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2ddc:	0d b4       	in	r0, 0x2d	; 45
    2dde:	07 fe       	sbrs	r0, 7
    2de0:	fd cf       	rjmp	.-6      	; 0x2ddc <sram_clear+0x1a>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2de2:	8d b5       	in	r24, 0x2d	; 45
    2de4:	81 60       	ori	r24, 0x01	; 1
    2de6:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2de8:	1e bc       	out	0x2e, r1	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2dea:	0d b4       	in	r0, 0x2d	; 45
    2dec:	07 fe       	sbrs	r0, 7
    2dee:	fd cf       	rjmp	.-6      	; 0x2dea <sram_clear+0x28>
    2df0:	80 e0       	ldi	r24, 0x00	; 0
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	a1 e0       	ldi	r26, 0x01	; 1
    2df6:	b0 e0       	ldi	r27, 0x00	; 0
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2df8:	2d b5       	in	r18, 0x2d	; 45
    2dfa:	21 60       	ori	r18, 0x01	; 1
    2dfc:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2dfe:	1e bc       	out	0x2e, r1	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e00:	0d b4       	in	r0, 0x2d	; 45
    2e02:	07 fe       	sbrs	r0, 7
    2e04:	fd cf       	rjmp	.-6      	; 0x2e00 <sram_clear+0x3e>
    2e06:	01 97       	sbiw	r24, 0x01	; 1
    2e08:	a1 09       	sbc	r26, r1
    2e0a:	b1 09       	sbc	r27, r1
void sram_clear(){
	uint32_t i;

	sram_enable();
	sram_cmd(SRAM_WRITE,0);
	for (i=0;i<SRAM_SIZE;i++){
    2e0c:	00 97       	sbiw	r24, 0x00	; 0
    2e0e:	a1 05       	cpc	r26, r1
    2e10:	b1 05       	cpc	r27, r1
    2e12:	91 f7       	brne	.-28     	; 0x2df8 <sram_clear+0x36>
		sram_send_byte(0);
	}
	sram_disable();
    2e14:	40 9a       	sbi	0x08, 0	; 8
    2e16:	08 95       	ret

00002e18 <sram_init>:

}

// initialisation de la SRAM
void sram_init(){
	SRAM_DDR |= SRAM_SEL;
    2e18:	38 9a       	sbi	0x07, 0	; 7
	sram_disable(); 
    2e1a:	40 9a       	sbi	0x08, 0	; 8
	//met la SRAM en mode squentiel
	sram_wrmode(SRAM_SQMD);
    2e1c:	80 e4       	ldi	r24, 0x40	; 64
    2e1e:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <sram_wrmode>
	//efface la SRAM
	sram_clear();
    2e22:	0c 94 e1 16 	jmp	0x2dc2	; 0x2dc2 <sram_clear>

00002e26 <sram_write_byte>:
}


// criture d'un octet dans la SRAM
void sram_write_byte(uint16_t addr, uint8_t data){
	sram_enable();
    2e26:	40 98       	cbi	0x08, 0	; 8
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e28:	2d b5       	in	r18, 0x2d	; 45
    2e2a:	21 60       	ori	r18, 0x01	; 1
    2e2c:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2e2e:	22 e0       	ldi	r18, 0x02	; 2
    2e30:	2e bd       	out	0x2e, r18	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e32:	0d b4       	in	r0, 0x2d	; 45
    2e34:	07 fe       	sbrs	r0, 7
    2e36:	fd cf       	rjmp	.-6      	; 0x2e32 <sram_write_byte+0xc>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e38:	2d b5       	in	r18, 0x2d	; 45
    2e3a:	21 60       	ori	r18, 0x01	; 1
    2e3c:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2e3e:	9e bd       	out	0x2e, r25	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e40:	0d b4       	in	r0, 0x2d	; 45
    2e42:	07 fe       	sbrs	r0, 7
    2e44:	fd cf       	rjmp	.-6      	; 0x2e40 <sram_write_byte+0x1a>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e46:	9d b5       	in	r25, 0x2d	; 45
    2e48:	91 60       	ori	r25, 0x01	; 1
    2e4a:	9d bd       	out	0x2d, r25	; 45
	SPI_DR = b;
    2e4c:	8e bd       	out	0x2e, r24	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e4e:	0d b4       	in	r0, 0x2d	; 45
    2e50:	07 fe       	sbrs	r0, 7
    2e52:	fd cf       	rjmp	.-6      	; 0x2e4e <sram_write_byte+0x28>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e54:	8d b5       	in	r24, 0x2d	; 45
    2e56:	81 60       	ori	r24, 0x01	; 1
    2e58:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2e5a:	6e bd       	out	0x2e, r22	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e5c:	0d b4       	in	r0, 0x2d	; 45
    2e5e:	07 fe       	sbrs	r0, 7
    2e60:	fd cf       	rjmp	.-6      	; 0x2e5c <sram_write_byte+0x36>
// criture d'un octet dans la SRAM
void sram_write_byte(uint16_t addr, uint8_t data){
	sram_enable();
	sram_cmd(SRAM_WRITE,addr);
	sram_send_byte(data);
	sram_disable();
    2e62:	40 9a       	sbi	0x08, 0	; 8
    2e64:	08 95       	ret

00002e66 <sram_read_word>:

// lecture d'un mot 16 bits
// ordre little indian
uint16_t sram_read_word(uint16_t addr){
	uint16_t w;
	sram_enable();
    2e66:	40 98       	cbi	0x08, 0	; 8
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e68:	2d b5       	in	r18, 0x2d	; 45
    2e6a:	21 60       	ori	r18, 0x01	; 1
    2e6c:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2e6e:	23 e0       	ldi	r18, 0x03	; 3
    2e70:	2e bd       	out	0x2e, r18	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e72:	0d b4       	in	r0, 0x2d	; 45
    2e74:	07 fe       	sbrs	r0, 7
    2e76:	fd cf       	rjmp	.-6      	; 0x2e72 <sram_read_word+0xc>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e78:	2d b5       	in	r18, 0x2d	; 45
    2e7a:	21 60       	ori	r18, 0x01	; 1
    2e7c:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2e7e:	9e bd       	out	0x2e, r25	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e80:	0d b4       	in	r0, 0x2d	; 45
    2e82:	07 fe       	sbrs	r0, 7
    2e84:	fd cf       	rjmp	.-6      	; 0x2e80 <sram_read_word+0x1a>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e86:	9d b5       	in	r25, 0x2d	; 45
    2e88:	91 60       	ori	r25, 0x01	; 1
    2e8a:	9d bd       	out	0x2d, r25	; 45
	SPI_DR = b;
    2e8c:	8e bd       	out	0x2e, r24	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e8e:	0d b4       	in	r0, 0x2d	; 45
    2e90:	07 fe       	sbrs	r0, 7
    2e92:	fd cf       	rjmp	.-6      	; 0x2e8e <sram_read_word+0x28>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2e94:	8d b5       	in	r24, 0x2d	; 45
    2e96:	81 60       	ori	r24, 0x01	; 1
    2e98:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2e9a:	1e bc       	out	0x2e, r1	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2e9c:	0d b4       	in	r0, 0x2d	; 45
    2e9e:	07 fe       	sbrs	r0, 7
    2ea0:	fd cf       	rjmp	.-6      	; 0x2e9c <sram_read_word+0x36>
uint16_t sram_read_word(uint16_t addr){
	uint16_t w;
	sram_enable();
	sram_cmd(SRAM_READ,addr);
	sram_send_byte(0);
	w=SPI_DR;
    2ea2:	8e b5       	in	r24, 0x2e	; 46
    2ea4:	90 e0       	ldi	r25, 0x00	; 0
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2ea6:	2d b5       	in	r18, 0x2d	; 45
    2ea8:	21 60       	ori	r18, 0x01	; 1
    2eaa:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2eac:	1e bc       	out	0x2e, r1	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2eae:	0d b4       	in	r0, 0x2d	; 45
    2eb0:	07 fe       	sbrs	r0, 7
    2eb2:	fd cf       	rjmp	.-6      	; 0x2eae <sram_read_word+0x48>
	sram_enable();
	sram_cmd(SRAM_READ,addr);
	sram_send_byte(0);
	w=SPI_DR;
	sram_send_byte(0);
	w |= SPI_DR<<8;
    2eb4:	2e b5       	in	r18, 0x2e	; 46
	sram_disable();
    2eb6:	40 9a       	sbi	0x08, 0	; 8
	return w;
}
    2eb8:	92 2b       	or	r25, r18
    2eba:	08 95       	ret

00002ebc <sram_load_block>:

// charge un bloc de mmoire SRAM dans un variable tableau.
void sram_load_block(uint16_t addr,int size, uint8_t *b){
	sram_enable();
    2ebc:	40 98       	cbi	0x08, 0	; 8
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2ebe:	2d b5       	in	r18, 0x2d	; 45
    2ec0:	21 60       	ori	r18, 0x01	; 1
    2ec2:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2ec4:	23 e0       	ldi	r18, 0x03	; 3
    2ec6:	2e bd       	out	0x2e, r18	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2ec8:	0d b4       	in	r0, 0x2d	; 45
    2eca:	07 fe       	sbrs	r0, 7
    2ecc:	fd cf       	rjmp	.-6      	; 0x2ec8 <sram_load_block+0xc>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2ece:	2d b5       	in	r18, 0x2d	; 45
    2ed0:	21 60       	ori	r18, 0x01	; 1
    2ed2:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2ed4:	9e bd       	out	0x2e, r25	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2ed6:	0d b4       	in	r0, 0x2d	; 45
    2ed8:	07 fe       	sbrs	r0, 7
    2eda:	fd cf       	rjmp	.-6      	; 0x2ed6 <sram_load_block+0x1a>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2edc:	9d b5       	in	r25, 0x2d	; 45
    2ede:	91 60       	ori	r25, 0x01	; 1
    2ee0:	9d bd       	out	0x2d, r25	; 45
	SPI_DR = b;
    2ee2:	8e bd       	out	0x2e, r24	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2ee4:	0d b4       	in	r0, 0x2d	; 45
    2ee6:	07 fe       	sbrs	r0, 7
    2ee8:	fd cf       	rjmp	.-6      	; 0x2ee4 <sram_load_block+0x28>
	uint16_t i;
	for (i=0;i<size;i++) sram_send_byte(*block++);
}

inline void sram_read_block(uint8_t *block, uint16_t size){
	while (size){
    2eea:	61 15       	cp	r22, r1
    2eec:	71 05       	cpc	r23, r1
    2eee:	79 f0       	breq	.+30     	; 0x2f0e <sram_load_block+0x52>
    2ef0:	fa 01       	movw	r30, r20
    2ef2:	64 0f       	add	r22, r20
    2ef4:	75 1f       	adc	r23, r21
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2ef6:	8d b5       	in	r24, 0x2d	; 45
    2ef8:	81 60       	ori	r24, 0x01	; 1
    2efa:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2efc:	1e bc       	out	0x2e, r1	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2efe:	0d b4       	in	r0, 0x2d	; 45
    2f00:	07 fe       	sbrs	r0, 7
    2f02:	fd cf       	rjmp	.-6      	; 0x2efe <sram_load_block+0x42>
}

inline void sram_read_block(uint8_t *block, uint16_t size){
	while (size){
		sram_send_byte(0);
		*block++=SPI_DR;
    2f04:	8e b5       	in	r24, 0x2e	; 46
    2f06:	81 93       	st	Z+, r24
	uint16_t i;
	for (i=0;i<size;i++) sram_send_byte(*block++);
}

inline void sram_read_block(uint8_t *block, uint16_t size){
	while (size){
    2f08:	e6 17       	cp	r30, r22
    2f0a:	f7 07       	cpc	r31, r23
    2f0c:	a1 f7       	brne	.-24     	; 0x2ef6 <sram_load_block+0x3a>
// charge un bloc de mmoire SRAM dans un variable tableau.
void sram_load_block(uint16_t addr,int size, uint8_t *b){
	sram_enable();
	sram_cmd(SRAM_READ,addr);
	sram_read_block(b,size);
	sram_disable();
    2f0e:	40 9a       	sbi	0x08, 0	; 8
    2f10:	08 95       	ret

00002f12 <sram_store_block>:
}

// transfert le contenu d'une variable tableau dans 
// la mmoire SRAM
void sram_store_block(uint16_t addr, int size, uint8_t *b){
	sram_enable();
    2f12:	40 98       	cbi	0x08, 0	; 8
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2f14:	2d b5       	in	r18, 0x2d	; 45
    2f16:	21 60       	ori	r18, 0x01	; 1
    2f18:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2f1a:	22 e0       	ldi	r18, 0x02	; 2
    2f1c:	2e bd       	out	0x2e, r18	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2f1e:	0d b4       	in	r0, 0x2d	; 45
    2f20:	07 fe       	sbrs	r0, 7
    2f22:	fd cf       	rjmp	.-6      	; 0x2f1e <sram_store_block+0xc>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2f24:	2d b5       	in	r18, 0x2d	; 45
    2f26:	21 60       	ori	r18, 0x01	; 1
    2f28:	2d bd       	out	0x2d, r18	; 45
	SPI_DR = b;
    2f2a:	9e bd       	out	0x2e, r25	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2f2c:	0d b4       	in	r0, 0x2d	; 45
    2f2e:	07 fe       	sbrs	r0, 7
    2f30:	fd cf       	rjmp	.-6      	; 0x2f2c <sram_store_block+0x1a>
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2f32:	9d b5       	in	r25, 0x2d	; 45
    2f34:	91 60       	ori	r25, 0x01	; 1
    2f36:	9d bd       	out	0x2d, r25	; 45
	SPI_DR = b;
    2f38:	8e bd       	out	0x2e, r24	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2f3a:	0d b4       	in	r0, 0x2d	; 45
    2f3c:	07 fe       	sbrs	r0, 7
    2f3e:	fd cf       	rjmp	.-6      	; 0x2f3a <sram_store_block+0x28>
							sram_send_byte(addr&0xff)
							
							
inline void sram_write_block(uint8_t *block,uint16_t size){
	uint16_t i;
	for (i=0;i<size;i++) sram_send_byte(*block++);
    2f40:	61 15       	cp	r22, r1
    2f42:	71 05       	cpc	r23, r1
    2f44:	71 f0       	breq	.+28     	; 0x2f62 <sram_store_block+0x50>
    2f46:	fa 01       	movw	r30, r20
    2f48:	64 0f       	add	r22, r20
    2f4a:	75 1f       	adc	r23, r21
    2f4c:	91 91       	ld	r25, Z+
#define sram_enable()  {SRAM_PORT &= ~SRAM_SEL;}
#define sram_disable() {SRAM_PORT |= SRAM_SEL;}


inline void sram_send_byte(unsigned char b){
	SPI_SR|=(1<<SPI2X);
    2f4e:	8d b5       	in	r24, 0x2d	; 45
    2f50:	81 60       	ori	r24, 0x01	; 1
    2f52:	8d bd       	out	0x2d, r24	; 45
	SPI_DR = b;
    2f54:	9e bd       	out	0x2e, r25	; 46
	while (!(SPI_SR&(1<<SPIF)));
    2f56:	0d b4       	in	r0, 0x2d	; 45
    2f58:	07 fe       	sbrs	r0, 7
    2f5a:	fd cf       	rjmp	.-6      	; 0x2f56 <sram_store_block+0x44>
							sram_send_byte(addr&0xff)
							
							
inline void sram_write_block(uint8_t *block,uint16_t size){
	uint16_t i;
	for (i=0;i<size;i++) sram_send_byte(*block++);
    2f5c:	e6 17       	cp	r30, r22
    2f5e:	f7 07       	cpc	r31, r23
    2f60:	a9 f7       	brne	.-22     	; 0x2f4c <sram_store_block+0x3a>
// la mmoire SRAM
void sram_store_block(uint16_t addr, int size, uint8_t *b){
	sram_enable();
	sram_cmd(SRAM_WRITE,addr);
	sram_write_block(b,size);
	sram_disable();
    2f62:	40 9a       	sbi	0x08, 0	; 8
    2f64:	08 95       	ret

00002f66 <tone_init>:




void tone_init(){
	TONE_DDR |= TONE_OUT;
    2f66:	56 9a       	sbi	0x0a, 6	; 10
	TONE_TCCRB = 3; // CLKt0=CLKio/64
    2f68:	83 e0       	ldi	r24, 0x03	; 3
    2f6a:	85 bd       	out	0x25, r24	; 37
	TONE_TCCRA = (1<<6)| 2; // OC0A toggle, mode 2 CTC
    2f6c:	82 e4       	ldi	r24, 0x42	; 66
    2f6e:	84 bd       	out	0x24, r24	; 36
    2f70:	08 95       	ret

00002f72 <tone>:
}


// frquence en hertz
// dure en  millisecondes
void tone(uint16_t freq, uint8_t length){
    2f72:	cf 93       	push	r28
    2f74:	c6 2f       	mov	r28, r22
	TONE_OCRA = (F_CPU/128)/freq-1;
    2f76:	9c 01       	movw	r18, r24
    2f78:	40 e0       	ldi	r20, 0x00	; 0
    2f7a:	50 e0       	ldi	r21, 0x00	; 0
    2f7c:	68 e4       	ldi	r22, 0x48	; 72
    2f7e:	78 ee       	ldi	r23, 0xE8	; 232
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	0e 94 c7 1a 	call	0x358e	; 0x358e <__divmodsi4>
    2f88:	21 50       	subi	r18, 0x01	; 1
    2f8a:	27 bd       	out	0x27, r18	; 39
	tone_on();
    2f8c:	56 9a       	sbi	0x0a, 6	; 10
	tone_length = length;
    2f8e:	c0 93 38 01 	sts	0x0138, r28
}
    2f92:	cf 91       	pop	r28
    2f94:	08 95       	ret

00002f96 <tvout_init>:
#include "tone.h"
#include "fat/byteordering.h"

void tvout_init(){
	// met broche sync en mode sortie
	NTSC_SYNC_DDR |= NTSC_SYNC_OUT;
    2f96:	22 9a       	sbi	0x04, 2	; 4
	//configuration USART0 pour mode SPI
	NSTC_VIDEO_CONFIG();
    2f98:	82 ec       	ldi	r24, 0xC2	; 194
    2f9a:	80 93 c2 00 	sts	0x00C2, r24
	//configuration PWM 16 bits pour sync video
	NTSC_SYNC_OCRA=HTIME;
    2f9e:	87 ef       	ldi	r24, 0xF7	; 247
    2fa0:	93 e0       	ldi	r25, 0x03	; 3
    2fa2:	90 93 89 00 	sts	0x0089, r25
    2fa6:	80 93 88 00 	sts	0x0088, r24
	NTSC_SYNC_OCRB=VPULSE;
    2faa:	83 e6       	ldi	r24, 0x63	; 99
    2fac:	93 e0       	ldi	r25, 0x03	; 3
    2fae:	90 93 8b 00 	sts	0x008B, r25
    2fb2:	80 93 8a 00 	sts	0x008A, r24
	//configuration mode PWM
	NTSC_SYNC_CONFIG();
    2fb6:	83 e3       	ldi	r24, 0x33	; 51
    2fb8:	80 93 80 00 	sts	0x0080, r24
    2fbc:	89 e1       	ldi	r24, 0x19	; 25
    2fbe:	80 93 81 00 	sts	0x0081, r24
	//activation interruption
	NTSC_SYNC_INT_ENABLE();
    2fc2:	ef e6       	ldi	r30, 0x6F	; 111
    2fc4:	f0 e0       	ldi	r31, 0x00	; 0
    2fc6:	80 81       	ld	r24, Z
    2fc8:	84 60       	ori	r24, 0x04	; 4
    2fca:	80 83       	st	Z, r24
    2fcc:	08 95       	ret

00002fce <put_sprite>:


// dessine un sprite 8 pixels x n pixels
// s'il y a collision retourne une valeur
// non nulle.
int8_t put_sprite(uint8_t x, uint8_t y, uint8_t n, const uint8_t *sprite, int8_t memory){
    2fce:	8f 92       	push	r8
    2fd0:	9f 92       	push	r9
    2fd2:	af 92       	push	r10
    2fd4:	bf 92       	push	r11
    2fd6:	cf 92       	push	r12
    2fd8:	df 92       	push	r13
    2fda:	ef 92       	push	r14
    2fdc:	ff 92       	push	r15
    2fde:	0f 93       	push	r16
    2fe0:	1f 93       	push	r17
    2fe2:	cf 93       	push	r28
    2fe4:	df 93       	push	r29
    2fe6:	90 2e       	mov	r9, r16
	int8_t xbyte,xbyte2, shl, shr, row, collision;
	uint8_t sprite_row;

	// contrle des limites
	x&=HRES-1;
    2fe8:	98 2f       	mov	r25, r24
    2fea:	9f 77       	andi	r25, 0x7F	; 127
	y&=VRES-1;
    2fec:	6f 73       	andi	r22, 0x3F	; 63
	collision=0;
	shr= x&7;
    2fee:	87 70       	andi	r24, 0x07	; 7
	shl=(8-shr)&7;
    2ff0:	08 2f       	mov	r16, r24
    2ff2:	01 95       	neg	r16
    2ff4:	07 70       	andi	r16, 0x07	; 7
	xbyte=x>>3;
    2ff6:	96 95       	lsr	r25
    2ff8:	96 95       	lsr	r25
    2ffa:	96 95       	lsr	r25
	xbyte2=(xbyte+1)&(HRES-1);
    2ffc:	cc 24       	eor	r12, r12
    2ffe:	c3 94       	inc	r12
    3000:	c9 0e       	add	r12, r25
	for (row=0;row<n;row++){
    3002:	c4 2f       	mov	r28, r20
    3004:	d0 e0       	ldi	r29, 0x00	; 0
    3006:	20 97       	sbiw	r28, 0x00	; 0
    3008:	09 f4       	brne	.+2      	; 0x300c <put_sprite+0x3e>
    300a:	60 c0       	rjmp	.+192    	; 0x30cc <put_sprite+0xfe>
    300c:	e9 2e       	mov	r14, r25
    300e:	f1 2c       	mov	r15, r1
    3010:	99 27       	eor	r25, r25
    3012:	87 fd       	sbrc	r24, 7
    3014:	90 95       	com	r25
	uint8_t sprite_row;

	// contrle des limites
	x&=HRES-1;
	y&=VRES-1;
	collision=0;
    3016:	70 e0       	ldi	r23, 0x00	; 0
	shr= x&7;
	shl=(8-shr)&7;
	xbyte=x>>3;
	xbyte2=(xbyte+1)&(HRES-1);
	for (row=0;row<n;row++){
    3018:	10 e0       	ldi	r17, 0x00	; 0
    301a:	e0 e0       	ldi	r30, 0x00	; 0
    301c:	f0 e0       	ldi	r31, 0x00	; 0
		}
		collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row>>shr);
		video_buffer[y*HBYTES+xbyte] ^= sprite_row>>shr;
		if (shl){
			//xbyte=(xbyte+1)&(HBYTES-1);
			collision |= video_buffer[y*HBYTES+xbyte2] & (sprite_row<<shl);
    301e:	d1 2c       	mov	r13, r1
    3020:	35 c0       	rjmp	.+106    	; 0x308c <put_sprite+0xbe>
	for (row=0;row<n;row++){
		//xbyte=x>>3;
		if (memory==RAM_MEM){
			sprite_row=sprite[row];
		}else{
			sprite_row= pgm_read_byte(sprite+row);
    3022:	e4 91       	lpm	r30, Z
		}
		collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row>>shr);
    3024:	40 e1       	ldi	r20, 0x10	; 16
    3026:	64 9f       	mul	r22, r20
    3028:	50 01       	movw	r10, r0
    302a:	11 24       	eor	r1, r1
    302c:	d5 01       	movw	r26, r10
    302e:	ae 0d       	add	r26, r14
    3030:	bf 1d       	adc	r27, r15
    3032:	a6 5c       	subi	r26, 0xC6	; 198
    3034:	be 4f       	sbci	r27, 0xFE	; 254
    3036:	8c 90       	ld	r8, X
    3038:	f0 e0       	ldi	r31, 0x00	; 0
    303a:	af 01       	movw	r20, r30
    303c:	08 2e       	mov	r0, r24
    303e:	02 c0       	rjmp	.+4      	; 0x3044 <put_sprite+0x76>
    3040:	55 95       	asr	r21
    3042:	47 95       	ror	r20
    3044:	0a 94       	dec	r0
    3046:	e2 f7       	brpl	.-8      	; 0x3040 <put_sprite+0x72>
    3048:	58 2d       	mov	r21, r8
    304a:	54 23       	and	r21, r20
    304c:	75 2b       	or	r23, r21
		video_buffer[y*HBYTES+xbyte] ^= sprite_row>>shr;
    304e:	48 25       	eor	r20, r8
    3050:	4c 93       	st	X, r20
		if (shl){
    3052:	00 23       	and	r16, r16
    3054:	81 f0       	breq	.+32     	; 0x3076 <put_sprite+0xa8>
			//xbyte=(xbyte+1)&(HBYTES-1);
			collision |= video_buffer[y*HBYTES+xbyte2] & (sprite_row<<shl);
    3056:	d5 01       	movw	r26, r10
    3058:	ac 0d       	add	r26, r12
    305a:	bd 1d       	adc	r27, r13
    305c:	a6 5c       	subi	r26, 0xC6	; 198
    305e:	be 4f       	sbci	r27, 0xFE	; 254
    3060:	4c 91       	ld	r20, X
    3062:	00 2e       	mov	r0, r16
    3064:	01 c0       	rjmp	.+2      	; 0x3068 <put_sprite+0x9a>
    3066:	ee 0f       	add	r30, r30
    3068:	0a 94       	dec	r0
    306a:	ea f7       	brpl	.-6      	; 0x3066 <put_sprite+0x98>
    306c:	54 2f       	mov	r21, r20
    306e:	5e 23       	and	r21, r30
    3070:	75 2b       	or	r23, r21
			video_buffer[y*HBYTES+xbyte2] ^= sprite_row<<shl;
    3072:	e4 27       	eor	r30, r20
    3074:	ec 93       	st	X, r30
		}
		y++;
    3076:	6f 5f       	subi	r22, 0xFF	; 255
		if (y==VRES) y=0;
    3078:	60 34       	cpi	r22, 0x40	; 64
    307a:	79 f0       	breq	.+30     	; 0x309a <put_sprite+0xcc>
    307c:	1f 5f       	subi	r17, 0xFF	; 255
	collision=0;
	shr= x&7;
	shl=(8-shr)&7;
	xbyte=x>>3;
	xbyte2=(xbyte+1)&(HRES-1);
	for (row=0;row<n;row++){
    307e:	e1 2f       	mov	r30, r17
    3080:	ff 27       	eor	r31, r31
    3082:	e7 fd       	sbrc	r30, 7
    3084:	f0 95       	com	r31
    3086:	ec 17       	cp	r30, r28
    3088:	fd 07       	cpc	r31, r29
    308a:	84 f4       	brge	.+32     	; 0x30ac <put_sprite+0xde>
		//xbyte=x>>3;
		if (memory==RAM_MEM){
    308c:	41 e0       	ldi	r20, 0x01	; 1
			sprite_row=sprite[row];
    308e:	e2 0f       	add	r30, r18
    3090:	f3 1f       	adc	r31, r19
	shl=(8-shr)&7;
	xbyte=x>>3;
	xbyte2=(xbyte+1)&(HRES-1);
	for (row=0;row<n;row++){
		//xbyte=x>>3;
		if (memory==RAM_MEM){
    3092:	94 12       	cpse	r9, r20
    3094:	c6 cf       	rjmp	.-116    	; 0x3022 <put_sprite+0x54>
			sprite_row=sprite[row];
    3096:	e0 81       	ld	r30, Z
    3098:	c5 cf       	rjmp	.-118    	; 0x3024 <put_sprite+0x56>
			//xbyte=(xbyte+1)&(HBYTES-1);
			collision |= video_buffer[y*HBYTES+xbyte2] & (sprite_row<<shl);
			video_buffer[y*HBYTES+xbyte2] ^= sprite_row<<shl;
		}
		y++;
		if (y==VRES) y=0;
    309a:	60 e0       	ldi	r22, 0x00	; 0
    309c:	1f 5f       	subi	r17, 0xFF	; 255
	collision=0;
	shr= x&7;
	shl=(8-shr)&7;
	xbyte=x>>3;
	xbyte2=(xbyte+1)&(HRES-1);
	for (row=0;row<n;row++){
    309e:	e1 2f       	mov	r30, r17
    30a0:	ff 27       	eor	r31, r31
    30a2:	e7 fd       	sbrc	r30, 7
    30a4:	f0 95       	com	r31
    30a6:	ec 17       	cp	r30, r28
    30a8:	fd 07       	cpc	r31, r29
    30aa:	84 f3       	brlt	.-32     	; 0x308c <put_sprite+0xbe>
    30ac:	81 e0       	ldi	r24, 0x01	; 1
    30ae:	77 23       	and	r23, r23
    30b0:	69 f0       	breq	.+26     	; 0x30cc <put_sprite+0xfe>
		y++;
		if (y==VRES) y=0;
	}
	if (collision) collision=1;
	return collision;
}
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	1f 91       	pop	r17
    30b8:	0f 91       	pop	r16
    30ba:	ff 90       	pop	r15
    30bc:	ef 90       	pop	r14
    30be:	df 90       	pop	r13
    30c0:	cf 90       	pop	r12
    30c2:	bf 90       	pop	r11
    30c4:	af 90       	pop	r10
    30c6:	9f 90       	pop	r9
    30c8:	8f 90       	pop	r8
    30ca:	08 95       	ret
	collision=0;
	shr= x&7;
	shl=(8-shr)&7;
	xbyte=x>>3;
	xbyte2=(xbyte+1)&(HRES-1);
	for (row=0;row<n;row++){
    30cc:	80 e0       	ldi	r24, 0x00	; 0
    30ce:	f1 cf       	rjmp	.-30     	; 0x30b2 <put_sprite+0xe4>

000030d0 <put_big_sprite>:

//dessine un sprite 16x16pixels
// le sprite est en mmoire RAM
// s'il y a collision retourne une valeur
// non nulle.
int8_t put_big_sprite(uint8_t x, uint8_t y,const uint8_t *sprite){
    30d0:	3f 92       	push	r3
    30d2:	4f 92       	push	r4
    30d4:	5f 92       	push	r5
    30d6:	6f 92       	push	r6
    30d8:	7f 92       	push	r7
    30da:	8f 92       	push	r8
    30dc:	9f 92       	push	r9
    30de:	af 92       	push	r10
    30e0:	bf 92       	push	r11
    30e2:	cf 92       	push	r12
    30e4:	df 92       	push	r13
    30e6:	ef 92       	push	r14
    30e8:	ff 92       	push	r15
    30ea:	0f 93       	push	r16
    30ec:	1f 93       	push	r17
    30ee:	cf 93       	push	r28
    30f0:	df 93       	push	r29
    30f2:	00 d0       	rcall	.+0      	; 0x30f4 <put_big_sprite+0x24>
    30f4:	00 d0       	rcall	.+0      	; 0x30f6 <put_big_sprite+0x26>
    30f6:	00 d0       	rcall	.+0      	; 0x30f8 <put_big_sprite+0x28>
    30f8:	cd b7       	in	r28, 0x3d	; 61
    30fa:	de b7       	in	r29, 0x3e	; 62
	int8_t xbyte, shl, shr, row, collision;
	uint8_t x2, sprite_row;

	// contrle des limites
	x&=HRES-1;
    30fc:	28 2f       	mov	r18, r24
    30fe:	2f 77       	andi	r18, 0x7F	; 127
	y&=VRES-1;
    3100:	6f 73       	andi	r22, 0x3F	; 63
	collision=0;
	x2=(x+8)&(HRES-1);
    3102:	38 e0       	ldi	r19, 0x08	; 8
    3104:	32 0f       	add	r19, r18
    3106:	93 2f       	mov	r25, r19
    3108:	9f 77       	andi	r25, 0x7F	; 127
	shr= x&7;
    310a:	87 70       	andi	r24, 0x07	; 7
	shl=(8-shr)&7;
    310c:	68 2e       	mov	r6, r24
    310e:	61 94       	neg	r6
    3110:	76 2d       	mov	r23, r6
    3112:	77 70       	andi	r23, 0x07	; 7
    3114:	67 2e       	mov	r6, r23
    3116:	26 95       	lsr	r18
    3118:	26 95       	lsr	r18
    311a:	26 95       	lsr	r18
    311c:	e2 2e       	mov	r14, r18
    311e:	f1 2c       	mov	r15, r1
    3120:	37 70       	andi	r19, 0x07	; 7
    3122:	a3 2e       	mov	r10, r19
    3124:	73 2f       	mov	r23, r19
    3126:	71 95       	neg	r23
    3128:	77 70       	andi	r23, 0x07	; 7
    312a:	96 95       	lsr	r25
    312c:	96 95       	lsr	r25
    312e:	96 95       	lsr	r25
    3130:	09 2f       	mov	r16, r25
    3132:	10 e0       	ldi	r17, 0x00	; 0
    3134:	a3 2f       	mov	r26, r19
    3136:	bb 27       	eor	r27, r27
    3138:	a7 fd       	sbrc	r26, 7
    313a:	b0 95       	com	r27
    313c:	bc 83       	std	Y+4, r27	; 0x04
    313e:	ab 83       	std	Y+3, r26	; 0x03
    3140:	fa 01       	movw	r30, r20
    3142:	31 96       	adiw	r30, 0x01	; 1
    3144:	4f 5d       	subi	r20, 0xDF	; 223
    3146:	5f 4f       	sbci	r21, 0xFF	; 255
	uint8_t x2, sprite_row;

	// contrle des limites
	x&=HRES-1;
	y&=VRES-1;
	collision=0;
    3148:	71 2c       	mov	r7, r1
		xbyte=x>>3;
		sprite_row=sprite[row];
		collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row>>shr);
		video_buffer[y*HBYTES+xbyte] ^= sprite_row>>shr;
		if (shl){
			xbyte=(xbyte+1)&(HBYTES-1);
    314a:	2f 5f       	subi	r18, 0xFF	; 255
    314c:	2f 70       	andi	r18, 0x0F	; 15
			collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row<<shl);
    314e:	42 2e       	mov	r4, r18
    3150:	55 24       	eor	r5, r5
    3152:	47 fc       	sbrc	r4, 7
    3154:	50 94       	com	r5
		xbyte =x2>>3;
		sprite_row=sprite[row];
		collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row>>shr);
		video_buffer[y*HBYTES+xbyte] ^= (sprite_row>>shr);
		if (shl){
			xbyte =(xbyte+1)&(HBYTES-1);
    3156:	9f 5f       	subi	r25, 0xFF	; 255
    3158:	9f 70       	andi	r25, 0x0F	; 15
			collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row<<shl);
    315a:	29 2f       	mov	r18, r25
    315c:	33 27       	eor	r19, r19
    315e:	27 fd       	sbrc	r18, 7
    3160:	30 95       	com	r19
    3162:	3a 83       	std	Y+2, r19	; 0x02
    3164:	29 83       	std	Y+1, r18	; 0x01
    3166:	07 c0       	rjmp	.+14     	; 0x3176 <put_big_sprite+0xa6>
    3168:	32 96       	adiw	r30, 0x02	; 2
	y&=VRES-1;
	collision=0;
	x2=(x+8)&(HRES-1);
	shr= x&7;
	shl=(8-shr)&7;
	for (row=0;row<32;row++){
    316a:	e4 17       	cp	r30, r20
    316c:	f5 07       	cpc	r31, r21
    316e:	09 f4       	brne	.+2      	; 0x3172 <put_big_sprite+0xa2>
    3170:	67 c0       	rjmp	.+206    	; 0x3240 <put_big_sprite+0x170>
			xbyte=(xbyte+1)&(HBYTES-1);
			collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row<<shl);
			video_buffer[y*HBYTES+xbyte] ^= sprite_row<<shl;
		}
		row++;
		shr=x2&7;
    3172:	8a 2d       	mov	r24, r10
	y&=VRES-1;
	collision=0;
	x2=(x+8)&(HRES-1);
	shr= x&7;
	shl=(8-shr)&7;
	for (row=0;row<32;row++){
    3174:	67 2e       	mov	r6, r23
		xbyte=x>>3;
		sprite_row=sprite[row];
		collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row>>shr);
    3176:	90 e1       	ldi	r25, 0x10	; 16
    3178:	69 9f       	mul	r22, r25
    317a:	90 01       	movw	r18, r0
    317c:	11 24       	eor	r1, r1
    317e:	d9 01       	movw	r26, r18
    3180:	ae 0d       	add	r26, r14
    3182:	bf 1d       	adc	r27, r15
    3184:	a6 5c       	subi	r26, 0xC6	; 198
    3186:	be 4f       	sbci	r27, 0xFE	; 254
    3188:	be 83       	std	Y+6, r27	; 0x06
    318a:	ad 83       	std	Y+5, r26	; 0x05
    318c:	3c 90       	ld	r3, X
    318e:	4f 01       	movw	r8, r30
    3190:	b1 e0       	ldi	r27, 0x01	; 1
    3192:	8b 1a       	sub	r8, r27
    3194:	91 08       	sbc	r9, r1
    3196:	d4 01       	movw	r26, r8
    3198:	cc 90       	ld	r12, X
    319a:	d1 2c       	mov	r13, r1
    319c:	d6 01       	movw	r26, r12
    319e:	02 c0       	rjmp	.+4      	; 0x31a4 <put_big_sprite+0xd4>
    31a0:	b5 95       	asr	r27
    31a2:	a7 95       	ror	r26
    31a4:	8a 95       	dec	r24
    31a6:	e2 f7       	brpl	.-8      	; 0x31a0 <put_big_sprite+0xd0>
    31a8:	cd 01       	movw	r24, r26
    31aa:	b3 2c       	mov	r11, r3
    31ac:	ba 22       	and	r11, r26
    31ae:	b7 28       	or	r11, r7
		video_buffer[y*HBYTES+xbyte] ^= sprite_row>>shr;
    31b0:	83 25       	eor	r24, r3
    31b2:	ad 81       	ldd	r26, Y+5	; 0x05
    31b4:	be 81       	ldd	r27, Y+6	; 0x06
    31b6:	8c 93       	st	X, r24
		if (shl){
    31b8:	66 20       	and	r6, r6
    31ba:	81 f0       	breq	.+32     	; 0x31dc <put_big_sprite+0x10c>
			xbyte=(xbyte+1)&(HBYTES-1);
			collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row<<shl);
    31bc:	d9 01       	movw	r26, r18
    31be:	a4 0d       	add	r26, r4
    31c0:	b5 1d       	adc	r27, r5
    31c2:	a6 5c       	subi	r26, 0xC6	; 198
    31c4:	be 4f       	sbci	r27, 0xFE	; 254
    31c6:	8c 91       	ld	r24, X
    31c8:	06 2c       	mov	r0, r6
    31ca:	01 c0       	rjmp	.+2      	; 0x31ce <put_big_sprite+0xfe>
    31cc:	cc 0c       	add	r12, r12
    31ce:	0a 94       	dec	r0
    31d0:	ea f7       	brpl	.-6      	; 0x31cc <put_big_sprite+0xfc>
    31d2:	98 2f       	mov	r25, r24
    31d4:	9c 21       	and	r25, r12
    31d6:	b9 2a       	or	r11, r25
			video_buffer[y*HBYTES+xbyte] ^= sprite_row<<shl;
    31d8:	c8 26       	eor	r12, r24
    31da:	cc 92       	st	X, r12
		row++;
		shr=x2&7;
		shl=(8-shr)&7;
		xbyte =x2>>3;
		sprite_row=sprite[row];
		collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row>>shr);
    31dc:	d9 01       	movw	r26, r18
    31de:	a0 0f       	add	r26, r16
    31e0:	b1 1f       	adc	r27, r17
    31e2:	a6 5c       	subi	r26, 0xC6	; 198
    31e4:	be 4f       	sbci	r27, 0xFE	; 254
    31e6:	9c 90       	ld	r9, X
    31e8:	c0 80       	ld	r12, Z
    31ea:	d1 2c       	mov	r13, r1
    31ec:	c6 01       	movw	r24, r12
    31ee:	0b 80       	ldd	r0, Y+3	; 0x03
    31f0:	02 c0       	rjmp	.+4      	; 0x31f6 <put_big_sprite+0x126>
    31f2:	95 95       	asr	r25
    31f4:	87 95       	ror	r24
    31f6:	0a 94       	dec	r0
    31f8:	e2 f7       	brpl	.-8      	; 0x31f2 <put_big_sprite+0x122>
    31fa:	79 2c       	mov	r7, r9
    31fc:	78 22       	and	r7, r24
    31fe:	7b 28       	or	r7, r11
		video_buffer[y*HBYTES+xbyte] ^= (sprite_row>>shr);
    3200:	89 25       	eor	r24, r9
    3202:	8c 93       	st	X, r24
		if (shl){
    3204:	77 23       	and	r23, r23
    3206:	91 f0       	breq	.+36     	; 0x322c <put_big_sprite+0x15c>
			xbyte =(xbyte+1)&(HBYTES-1);
			collision |= video_buffer[y*HBYTES+xbyte] & (sprite_row<<shl);
    3208:	89 81       	ldd	r24, Y+1	; 0x01
    320a:	9a 81       	ldd	r25, Y+2	; 0x02
    320c:	28 0f       	add	r18, r24
    320e:	39 1f       	adc	r19, r25
    3210:	26 5c       	subi	r18, 0xC6	; 198
    3212:	3e 4f       	sbci	r19, 0xFE	; 254
    3214:	d9 01       	movw	r26, r18
    3216:	8c 91       	ld	r24, X
    3218:	07 2e       	mov	r0, r23
    321a:	01 c0       	rjmp	.+2      	; 0x321e <put_big_sprite+0x14e>
    321c:	cc 0c       	add	r12, r12
    321e:	0a 94       	dec	r0
    3220:	ea f7       	brpl	.-6      	; 0x321c <put_big_sprite+0x14c>
    3222:	98 2f       	mov	r25, r24
    3224:	9c 21       	and	r25, r12
    3226:	79 2a       	or	r7, r25
			video_buffer[y*HBYTES+xbyte] ^=(sprite_row<<shl);
    3228:	c8 26       	eor	r12, r24
    322a:	cc 92       	st	X, r12
		}
		y++;
    322c:	6f 5f       	subi	r22, 0xFF	; 255
		if (y==VRES) y=0;
    322e:	60 34       	cpi	r22, 0x40	; 64
    3230:	09 f0       	breq	.+2      	; 0x3234 <put_big_sprite+0x164>
    3232:	9a cf       	rjmp	.-204    	; 0x3168 <put_big_sprite+0x98>
    3234:	60 e0       	ldi	r22, 0x00	; 0
    3236:	32 96       	adiw	r30, 0x02	; 2
	y&=VRES-1;
	collision=0;
	x2=(x+8)&(HRES-1);
	shr= x&7;
	shl=(8-shr)&7;
	for (row=0;row<32;row++){
    3238:	e4 17       	cp	r30, r20
    323a:	f5 07       	cpc	r31, r21
    323c:	09 f0       	breq	.+2      	; 0x3240 <put_big_sprite+0x170>
    323e:	99 cf       	rjmp	.-206    	; 0x3172 <put_big_sprite+0xa2>
			video_buffer[y*HBYTES+xbyte] ^=(sprite_row<<shl);
		}
		y++;
		if (y==VRES) y=0;
	}
	if (collision) collision=1;
    3240:	81 e0       	ldi	r24, 0x01	; 1
    3242:	71 10       	cpse	r7, r1
    3244:	01 c0       	rjmp	.+2      	; 0x3248 <put_big_sprite+0x178>
    3246:	80 e0       	ldi	r24, 0x00	; 0
	return collision;
}
    3248:	26 96       	adiw	r28, 0x06	; 6
    324a:	0f b6       	in	r0, 0x3f	; 63
    324c:	f8 94       	cli
    324e:	de bf       	out	0x3e, r29	; 62
    3250:	0f be       	out	0x3f, r0	; 63
    3252:	cd bf       	out	0x3d, r28	; 61
    3254:	df 91       	pop	r29
    3256:	cf 91       	pop	r28
    3258:	1f 91       	pop	r17
    325a:	0f 91       	pop	r16
    325c:	ff 90       	pop	r15
    325e:	ef 90       	pop	r14
    3260:	df 90       	pop	r13
    3262:	cf 90       	pop	r12
    3264:	bf 90       	pop	r11
    3266:	af 90       	pop	r10
    3268:	9f 90       	pop	r9
    326a:	8f 90       	pop	r8
    326c:	7f 90       	pop	r7
    326e:	6f 90       	pop	r6
    3270:	5f 90       	pop	r5
    3272:	4f 90       	pop	r4
    3274:	3f 90       	pop	r3
    3276:	08 95       	ret

00003278 <cls>:


void cls(){
	memset(video_buffer,0,VRES*HBYTES);	
    3278:	80 e0       	ldi	r24, 0x00	; 0
    327a:	94 e0       	ldi	r25, 0x04	; 4
    327c:	ea e3       	ldi	r30, 0x3A	; 58
    327e:	f1 e0       	ldi	r31, 0x01	; 1
    3280:	df 01       	movw	r26, r30
    3282:	9c 01       	movw	r18, r24
    3284:	1d 92       	st	X+, r1
    3286:	21 50       	subi	r18, 0x01	; 1
    3288:	30 40       	sbci	r19, 0x00	; 0
    328a:	e1 f7       	brne	.-8      	; 0x3284 <cls+0xc>
	set_cursor(0,0);
    328c:	60 e0       	ldi	r22, 0x00	; 0
    328e:	80 e0       	ldi	r24, 0x00	; 0
    3290:	0c 94 06 16 	jmp	0x2c0c	; 0x2c0c <set_cursor>

00003294 <scroll_down>:
}


// lines {1..31}
void scroll_down(uint8_t lines){
    3294:	cf 93       	push	r28
    3296:	df 93       	push	r29
	if (!lines) return;
    3298:	81 11       	cpse	r24, r1
    329a:	03 c0       	rjmp	.+6      	; 0x32a2 <scroll_down+0xe>
	lines &=0x1f;
	memmove(video_buffer+HBYTES*lines,video_buffer,HBYTES*VRES-HBYTES*lines);
	memset(video_buffer,0,HBYTES*lines);	
}
    329c:	df 91       	pop	r29
    329e:	cf 91       	pop	r28
    32a0:	08 95       	ret


// lines {1..31}
void scroll_down(uint8_t lines){
	if (!lines) return;
	lines &=0x1f;
    32a2:	8f 71       	andi	r24, 0x1F	; 31
	memmove(video_buffer+HBYTES*lines,video_buffer,HBYTES*VRES-HBYTES*lines);
    32a4:	90 e0       	ldi	r25, 0x00	; 0
    32a6:	ec 01       	movw	r28, r24
    32a8:	c2 95       	swap	r28
    32aa:	d2 95       	swap	r29
    32ac:	d0 7f       	andi	r29, 0xF0	; 240
    32ae:	dc 27       	eor	r29, r28
    32b0:	c0 7f       	andi	r28, 0xF0	; 240
    32b2:	dc 27       	eor	r29, r28
    32b4:	40 e4       	ldi	r20, 0x40	; 64
    32b6:	50 e0       	ldi	r21, 0x00	; 0
    32b8:	48 1b       	sub	r20, r24
    32ba:	59 0b       	sbc	r21, r25
    32bc:	42 95       	swap	r20
    32be:	52 95       	swap	r21
    32c0:	50 7f       	andi	r21, 0xF0	; 240
    32c2:	54 27       	eor	r21, r20
    32c4:	40 7f       	andi	r20, 0xF0	; 240
    32c6:	54 27       	eor	r21, r20
    32c8:	6a e3       	ldi	r22, 0x3A	; 58
    32ca:	71 e0       	ldi	r23, 0x01	; 1
    32cc:	ce 01       	movw	r24, r28
    32ce:	86 5c       	subi	r24, 0xC6	; 198
    32d0:	9e 4f       	sbci	r25, 0xFE	; 254
    32d2:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <memmove>
	memset(video_buffer,0,HBYTES*lines);	
    32d6:	ae 01       	movw	r20, r28
    32d8:	60 e0       	ldi	r22, 0x00	; 0
    32da:	70 e0       	ldi	r23, 0x00	; 0
    32dc:	8a e3       	ldi	r24, 0x3A	; 58
    32de:	91 e0       	ldi	r25, 0x01	; 1
}
    32e0:	df 91       	pop	r29
    32e2:	cf 91       	pop	r28
// lines {1..31}
void scroll_down(uint8_t lines){
	if (!lines) return;
	lines &=0x1f;
	memmove(video_buffer+HBYTES*lines,video_buffer,HBYTES*VRES-HBYTES*lines);
	memset(video_buffer,0,HBYTES*lines);	
    32e4:	0c 94 76 1b 	jmp	0x36ec	; 0x36ec <memset>

000032e8 <scroll_up>:
}


// lines {1..31}
void scroll_up(uint8_t lines){
    32e8:	0f 93       	push	r16
    32ea:	1f 93       	push	r17
    32ec:	cf 93       	push	r28
    32ee:	df 93       	push	r29
	if (!lines) return;
    32f0:	81 11       	cpse	r24, r1
    32f2:	05 c0       	rjmp	.+10     	; 0x32fe <scroll_up+0x16>
	lines &=0x1f;
	memmove(video_buffer,video_buffer+HBYTES*lines,HBYTES*VRES-HBYTES*lines);	
	memset(video_buffer+HBYTES*VRES-HBYTES*lines,0,HBYTES*lines);
}
    32f4:	df 91       	pop	r29
    32f6:	cf 91       	pop	r28
    32f8:	1f 91       	pop	r17
    32fa:	0f 91       	pop	r16
    32fc:	08 95       	ret


// lines {1..31}
void scroll_up(uint8_t lines){
	if (!lines) return;
	lines &=0x1f;
    32fe:	8f 71       	andi	r24, 0x1F	; 31
	memmove(video_buffer,video_buffer+HBYTES*lines,HBYTES*VRES-HBYTES*lines);	
    3300:	08 2f       	mov	r16, r24
    3302:	10 e0       	ldi	r17, 0x00	; 0
    3304:	e8 01       	movw	r28, r16
    3306:	c2 95       	swap	r28
    3308:	d2 95       	swap	r29
    330a:	d0 7f       	andi	r29, 0xF0	; 240
    330c:	dc 27       	eor	r29, r28
    330e:	c0 7f       	andi	r28, 0xF0	; 240
    3310:	dc 27       	eor	r29, r28
    3312:	40 e4       	ldi	r20, 0x40	; 64
    3314:	50 e0       	ldi	r21, 0x00	; 0
    3316:	40 1b       	sub	r20, r16
    3318:	51 0b       	sbc	r21, r17
    331a:	42 95       	swap	r20
    331c:	52 95       	swap	r21
    331e:	50 7f       	andi	r21, 0xF0	; 240
    3320:	54 27       	eor	r21, r20
    3322:	40 7f       	andi	r20, 0xF0	; 240
    3324:	54 27       	eor	r21, r20
    3326:	be 01       	movw	r22, r28
    3328:	66 5c       	subi	r22, 0xC6	; 198
    332a:	7e 4f       	sbci	r23, 0xFE	; 254
    332c:	8a e3       	ldi	r24, 0x3A	; 58
    332e:	91 e0       	ldi	r25, 0x01	; 1
    3330:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <memmove>
	memset(video_buffer+HBYTES*VRES-HBYTES*lines,0,HBYTES*lines);
    3334:	20 ef       	ldi	r18, 0xF0	; 240
    3336:	20 03       	mulsu	r18, r16
    3338:	c0 01       	movw	r24, r0
    333a:	21 9f       	mul	r18, r17
    333c:	90 0d       	add	r25, r0
    333e:	11 24       	eor	r1, r1
    3340:	ae 01       	movw	r20, r28
    3342:	60 e0       	ldi	r22, 0x00	; 0
    3344:	70 e0       	ldi	r23, 0x00	; 0
    3346:	86 5c       	subi	r24, 0xC6	; 198
    3348:	9a 4f       	sbci	r25, 0xFA	; 250
}
    334a:	df 91       	pop	r29
    334c:	cf 91       	pop	r28
    334e:	1f 91       	pop	r17
    3350:	0f 91       	pop	r16
// lines {1..31}
void scroll_up(uint8_t lines){
	if (!lines) return;
	lines &=0x1f;
	memmove(video_buffer,video_buffer+HBYTES*lines,HBYTES*VRES-HBYTES*lines);	
	memset(video_buffer+HBYTES*VRES-HBYTES*lines,0,HBYTES*lines);
    3352:	0c 94 76 1b 	jmp	0x36ec	; 0x36ec <memset>

00003356 <chip_scroll_right>:
	}
}

// optimis pour la VM chip8()
// dcale de 4 pixels
void chip_scroll_right(){
    3356:	cf 93       	push	r28
    3358:	df 93       	push	r29
    335a:	ca e3       	ldi	r28, 0x3A	; 58
    335c:	d1 e0       	ldi	r29, 0x01	; 1
    335e:	ae 01       	movw	r20, r28
    3360:	40 5f       	subi	r20, 0xF0	; 240
    3362:	5f 4f       	sbci	r21, 0xFF	; 255
    3364:	9e 01       	movw	r18, r28
    3366:	2f 5f       	subi	r18, 0xFF	; 255
    3368:	3f 4f       	sbci	r19, 0xFF	; 255
    336a:	de 01       	movw	r26, r28
    336c:	1f 96       	adiw	r26, 0x0f	; 15
    336e:	fa 01       	movw	r30, r20
	uint8_t *line_buffer;

	for (line=1;line<=VRES;line++){
		line_buffer=video_buffer+HBYTES*line-1;
		for (column=HBYTES-1;column;column--){
			*line_buffer=(*line_buffer>>4)|((*(line_buffer-1))<<4);
    3370:	8e 91       	ld	r24, -X
    3372:	60 e1       	ldi	r22, 0x10	; 16
    3374:	86 9f       	mul	r24, r22
    3376:	c0 01       	movw	r24, r0
    3378:	11 24       	eor	r1, r1
    337a:	92 91       	ld	r25, -Z
    337c:	92 95       	swap	r25
    337e:	9f 70       	andi	r25, 0x0F	; 15
    3380:	98 2b       	or	r25, r24
    3382:	90 83       	st	Z, r25
	uint8_t line, column;
	uint8_t *line_buffer;

	for (line=1;line<=VRES;line++){
		line_buffer=video_buffer+HBYTES*line-1;
		for (column=HBYTES-1;column;column--){
    3384:	e2 17       	cp	r30, r18
    3386:	f3 07       	cpc	r31, r19
    3388:	99 f7       	brne	.-26     	; 0x3370 <chip_scroll_right+0x1a>
			*line_buffer=(*line_buffer>>4)|((*(line_buffer-1))<<4);
			--line_buffer;
		}
		*line_buffer>>=4;
    338a:	88 81       	ld	r24, Y
    338c:	82 95       	swap	r24
    338e:	8f 70       	andi	r24, 0x0F	; 15
    3390:	88 83       	st	Y, r24
// dcale de 4 pixels
void chip_scroll_right(){
	uint8_t line, column;
	uint8_t *line_buffer;

	for (line=1;line<=VRES;line++){
    3392:	85 e0       	ldi	r24, 0x05	; 5
    3394:	4a 33       	cpi	r20, 0x3A	; 58
    3396:	58 07       	cpc	r21, r24
    3398:	11 f0       	breq	.+4      	; 0x339e <chip_scroll_right+0x48>
    339a:	ea 01       	movw	r28, r20
    339c:	e0 cf       	rjmp	.-64     	; 0x335e <chip_scroll_right+0x8>
			*line_buffer=(*line_buffer>>4)|((*(line_buffer-1))<<4);
			--line_buffer;
		}
		*line_buffer>>=4;
	}
}
    339e:	df 91       	pop	r29
    33a0:	cf 91       	pop	r28
    33a2:	08 95       	ret

000033a4 <chip_scroll_left>:
	}
}

// optimis pour la VM chip8()
// dcale de 4 pixels
void chip_scroll_left(){
    33a4:	29 e4       	ldi	r18, 0x49	; 73
    33a6:	31 e0       	ldi	r19, 0x01	; 1
    33a8:	f9 01       	movw	r30, r18
    33aa:	3f 97       	sbiw	r30, 0x0f	; 15
    33ac:	d9 01       	movw	r26, r18
    33ae:	1e 97       	sbiw	r26, 0x0e	; 14
	uint8_t line, column;
	uint8_t  *line_buffer;
	for (line=0;line<VRES;line++){
		line_buffer=video_buffer+HBYTES*line;
		for (column=0;column<(HBYTES-1);column++){
			*line_buffer=(*line_buffer<<4)|((*(line_buffer+1))>>4);
    33b0:	4d 91       	ld	r20, X+
    33b2:	42 95       	swap	r20
    33b4:	4f 70       	andi	r20, 0x0F	; 15
    33b6:	80 81       	ld	r24, Z
    33b8:	50 e1       	ldi	r21, 0x10	; 16
    33ba:	85 9f       	mul	r24, r21
    33bc:	c0 01       	movw	r24, r0
    33be:	11 24       	eor	r1, r1
    33c0:	48 2b       	or	r20, r24
    33c2:	41 93       	st	Z+, r20
void chip_scroll_left(){
	uint8_t line, column;
	uint8_t  *line_buffer;
	for (line=0;line<VRES;line++){
		line_buffer=video_buffer+HBYTES*line;
		for (column=0;column<(HBYTES-1);column++){
    33c4:	e2 17       	cp	r30, r18
    33c6:	f3 07       	cpc	r31, r19
    33c8:	99 f7       	brne	.-26     	; 0x33b0 <chip_scroll_left+0xc>
			*line_buffer=(*line_buffer<<4)|((*(line_buffer+1))>>4);
			++line_buffer;
		}
		*line_buffer<<=4;
    33ca:	80 81       	ld	r24, Z
    33cc:	82 95       	swap	r24
    33ce:	80 7f       	andi	r24, 0xF0	; 240
    33d0:	80 83       	st	Z, r24
    33d2:	9f 01       	movw	r18, r30
    33d4:	20 5f       	subi	r18, 0xF0	; 240
    33d6:	3f 4f       	sbci	r19, 0xFF	; 255
// optimis pour la VM chip8()
// dcale de 4 pixels
void chip_scroll_left(){
	uint8_t line, column;
	uint8_t  *line_buffer;
	for (line=0;line<VRES;line++){
    33d8:	85 e0       	ldi	r24, 0x05	; 5
    33da:	29 34       	cpi	r18, 0x49	; 73
    33dc:	38 07       	cpc	r19, r24
    33de:	21 f7       	brne	.-56     	; 0x33a8 <chip_scroll_left+0x4>
			*line_buffer=(*line_buffer<<4)|((*(line_buffer+1))>>4);
			++line_buffer;
		}
		*line_buffer<<=4;
	}
}
    33e0:	08 95       	ret

000033e2 <__vector_12>:
static volatile uint16_t line_count=0;
static volatile uint8_t video=0;

// interruption  la fin de
// chaque pulse de synchronisation
ISR(TIMER1_COMPB_vect){
    33e2:	1f 92       	push	r1
    33e4:	0f 92       	push	r0
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	0f 92       	push	r0
    33ea:	11 24       	eor	r1, r1
    33ec:	2f 93       	push	r18
    33ee:	8f 93       	push	r24
    33f0:	9f 93       	push	r25
    33f2:	ef 93       	push	r30
    33f4:	ff 93       	push	r31
	register unsigned i;
	register unsigned char *buff;

	line_count++;
    33f6:	80 91 35 01 	lds	r24, 0x0135
    33fa:	90 91 36 01 	lds	r25, 0x0136
    33fe:	01 96       	adiw	r24, 0x01	; 1
    3400:	90 93 36 01 	sts	0x0136, r25
    3404:	80 93 35 01 	sts	0x0135, r24
	switch(line_count){
    3408:	80 91 35 01 	lds	r24, 0x0135
    340c:	90 91 36 01 	lds	r25, 0x0136
    3410:	84 30       	cpi	r24, 0x04	; 4
    3412:	91 05       	cpc	r25, r1
    3414:	09 f4       	brne	.+2      	; 0x3418 <__vector_12+0x36>
    3416:	47 c0       	rjmp	.+142    	; 0x34a6 <__vector_12+0xc4>
    3418:	b0 f0       	brcs	.+44     	; 0x3446 <__vector_12+0x64>
    341a:	8c 33       	cpi	r24, 0x3C	; 60
    341c:	91 05       	cpc	r25, r1
    341e:	b9 f1       	breq	.+110    	; 0x348e <__vector_12+0xac>
    3420:	d0 f1       	brcs	.+116    	; 0x3496 <__vector_12+0xb4>
    3422:	8b 3b       	cpi	r24, 0xBB	; 187
    3424:	91 05       	cpc	r25, r1
    3426:	49 f1       	breq	.+82     	; 0x347a <__vector_12+0x98>
    3428:	86 30       	cpi	r24, 0x06	; 6
    342a:	91 40       	sbci	r25, 0x01	; 1
    342c:	09 f0       	breq	.+2      	; 0x3430 <__vector_12+0x4e>
    342e:	45 c0       	rjmp	.+138    	; 0x34ba <__vector_12+0xd8>
			break;
		case LAST_VISIBLE:
			video=0;
			break;
		case 262:
			line_count=0;
    3430:	10 92 36 01 	sts	0x0136, r1
    3434:	10 92 35 01 	sts	0x0135, r1
			NTSC_SYNC_OCRB=VPULSE;
    3438:	83 e6       	ldi	r24, 0x63	; 99
    343a:	93 e0       	ldi	r25, 0x03	; 3
    343c:	90 93 8b 00 	sts	0x008B, r25
    3440:	80 93 8a 00 	sts	0x008A, r24
			break;
    3444:	10 c0       	rjmp	.+32     	; 0x3466 <__vector_12+0x84>
ISR(TIMER1_COMPB_vect){
	register unsigned i;
	register unsigned char *buff;

	line_count++;
	switch(line_count){
    3446:	82 30       	cpi	r24, 0x02	; 2
    3448:	91 05       	cpc	r25, r1
    344a:	09 f4       	brne	.+2      	; 0x344e <__vector_12+0x6c>
    344c:	6e c0       	rjmp	.+220    	; 0x352a <__vector_12+0x148>
    344e:	c0 f4       	brcc	.+48     	; 0x3480 <__vector_12+0x9e>
    3450:	01 97       	sbiw	r24, 0x01	; 1
    3452:	99 f5       	brne	.+102    	; 0x34ba <__vector_12+0xd8>
		case 1:
			if (frame_delay) frame_delay--;
    3454:	80 91 39 01 	lds	r24, 0x0139
    3458:	88 23       	and	r24, r24
    345a:	29 f0       	breq	.+10     	; 0x3466 <__vector_12+0x84>
    345c:	80 91 39 01 	lds	r24, 0x0139
    3460:	81 50       	subi	r24, 0x01	; 1
    3462:	80 93 39 01 	sts	0x0139, r24
				while (!(NTSC_VIDEO_UCSRA & (1<<TXC0)));
				NTSC_VIDEO_UCSRB &= ~(1<<TXEN0);
			}
			break;
	}//switch
}
    3466:	ff 91       	pop	r31
    3468:	ef 91       	pop	r30
    346a:	9f 91       	pop	r25
    346c:	8f 91       	pop	r24
    346e:	2f 91       	pop	r18
    3470:	0f 90       	pop	r0
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	0f 90       	pop	r0
    3476:	1f 90       	pop	r1
    3478:	18 95       	reti
			break;
		case FIRST_VISIBLE:
			video=1;
			break;
		case LAST_VISIBLE:
			video=0;
    347a:	10 92 34 01 	sts	0x0134, r1
			break;
    347e:	f3 cf       	rjmp	.-26     	; 0x3466 <__vector_12+0x84>
			tone_length--;
			if (!tone_length) tone_off();
		}
		break;
		case 3:
			NTSC_SYNC_OCRB=HPULSE;
    3480:	8a e4       	ldi	r24, 0x4A	; 74
    3482:	90 e0       	ldi	r25, 0x00	; 0
    3484:	90 93 8b 00 	sts	0x008B, r25
    3488:	80 93 8a 00 	sts	0x008A, r24
			break;
    348c:	ec cf       	rjmp	.-40     	; 0x3466 <__vector_12+0x84>
			break;
		case 5:
			ADCSRA |= (1<<ADSC);
			break;
		case FIRST_VISIBLE:
			video=1;
    348e:	81 e0       	ldi	r24, 0x01	; 1
    3490:	80 93 34 01 	sts	0x0134, r24
			break;
    3494:	e8 cf       	rjmp	.-48     	; 0x3466 <__vector_12+0x84>
ISR(TIMER1_COMPB_vect){
	register unsigned i;
	register unsigned char *buff;

	line_count++;
	switch(line_count){
    3496:	05 97       	sbiw	r24, 0x05	; 5
    3498:	81 f4       	brne	.+32     	; 0x34ba <__vector_12+0xd8>
			break;
		case 4:
			if (speed_delay) speed_delay--;
			break;
		case 5:
			ADCSRA |= (1<<ADSC);
    349a:	80 91 7a 00 	lds	r24, 0x007A
    349e:	80 64       	ori	r24, 0x40	; 64
    34a0:	80 93 7a 00 	sts	0x007A, r24
			break;
    34a4:	e0 cf       	rjmp	.-64     	; 0x3466 <__vector_12+0x84>
		break;
		case 3:
			NTSC_SYNC_OCRB=HPULSE;
			break;
		case 4:
			if (speed_delay) speed_delay--;
    34a6:	80 91 37 01 	lds	r24, 0x0137
    34aa:	88 23       	and	r24, r24
    34ac:	e1 f2       	breq	.-72     	; 0x3466 <__vector_12+0x84>
    34ae:	80 91 37 01 	lds	r24, 0x0137
    34b2:	81 50       	subi	r24, 0x01	; 1
    34b4:	80 93 37 01 	sts	0x0137, r24
    34b8:	d6 cf       	rjmp	.-84     	; 0x3466 <__vector_12+0x84>
		case 262:
			line_count=0;
			NTSC_SYNC_OCRB=VPULSE;
			break;
		default:
			if (video){
    34ba:	80 91 34 01 	lds	r24, 0x0134
    34be:	88 23       	and	r24, r24
    34c0:	91 f2       	breq	.-92     	; 0x3466 <__vector_12+0x84>
				buff=video_buffer+(((line_count-FIRST_VISIBLE)>>1)*HBYTES);
    34c2:	e0 91 35 01 	lds	r30, 0x0135
    34c6:	f0 91 36 01 	lds	r31, 0x0136
				NTSC_VIDEO_UBRR=0;
    34ca:	10 92 c5 00 	sts	0x00C5, r1
    34ce:	10 92 c4 00 	sts	0x00C4, r1
				NTSC_VIDEO_UCSRB=(1<<TXEN0);
    34d2:	88 e0       	ldi	r24, 0x08	; 8
    34d4:	80 93 c1 00 	sts	0x00C1, r24
				NTSC_VIDEO_UBRR=2;
    34d8:	82 e0       	ldi	r24, 0x02	; 2
    34da:	90 e0       	ldi	r25, 0x00	; 0
    34dc:	90 93 c5 00 	sts	0x00C5, r25
    34e0:	80 93 c4 00 	sts	0x00C4, r24
				NTSC_VIDEO_UDR=0x0;
    34e4:	10 92 c6 00 	sts	0x00C6, r1
			line_count=0;
			NTSC_SYNC_OCRB=VPULSE;
			break;
		default:
			if (video){
				buff=video_buffer+(((line_count-FIRST_VISIBLE)>>1)*HBYTES);
    34e8:	fc 97       	sbiw	r30, 0x3c	; 60
    34ea:	f6 95       	lsr	r31
    34ec:	e7 95       	ror	r30
    34ee:	e2 95       	swap	r30
    34f0:	f2 95       	swap	r31
    34f2:	f0 7f       	andi	r31, 0xF0	; 240
    34f4:	fe 27       	eor	r31, r30
    34f6:	e0 7f       	andi	r30, 0xF0	; 240
    34f8:	fe 27       	eor	r31, r30
    34fa:	e6 5c       	subi	r30, 0xC6	; 198
    34fc:	fe 4f       	sbci	r31, 0xFE	; 254
    34fe:	cf 01       	movw	r24, r30
    3500:	40 96       	adiw	r24, 0x10	; 16
				NTSC_VIDEO_UBRR=0;
				NTSC_VIDEO_UCSRB=(1<<TXEN0);
				NTSC_VIDEO_UBRR=2;
				NTSC_VIDEO_UDR=0x0;
				for (i=HBYTES;i;i--){
					while ( !( UCSR0A & (1<<UDRE0)) );
    3502:	20 91 c0 00 	lds	r18, 0x00C0
    3506:	25 ff       	sbrs	r18, 5
    3508:	fc cf       	rjmp	.-8      	; 0x3502 <__vector_12+0x120>
					NTSC_VIDEO_UDR=*buff++;
    350a:	21 91       	ld	r18, Z+
    350c:	20 93 c6 00 	sts	0x00C6, r18
				buff=video_buffer+(((line_count-FIRST_VISIBLE)>>1)*HBYTES);
				NTSC_VIDEO_UBRR=0;
				NTSC_VIDEO_UCSRB=(1<<TXEN0);
				NTSC_VIDEO_UBRR=2;
				NTSC_VIDEO_UDR=0x0;
				for (i=HBYTES;i;i--){
    3510:	e8 17       	cp	r30, r24
    3512:	f9 07       	cpc	r31, r25
    3514:	b1 f7       	brne	.-20     	; 0x3502 <__vector_12+0x120>
					while ( !( UCSR0A & (1<<UDRE0)) );
					NTSC_VIDEO_UDR=*buff++;
				}
				while (!(NTSC_VIDEO_UCSRA & (1<<TXC0)));
    3516:	80 91 c0 00 	lds	r24, 0x00C0
    351a:	86 ff       	sbrs	r24, 6
    351c:	fc cf       	rjmp	.-8      	; 0x3516 <__vector_12+0x134>
				NTSC_VIDEO_UCSRB &= ~(1<<TXEN0);
    351e:	80 91 c1 00 	lds	r24, 0x00C1
    3522:	87 7f       	andi	r24, 0xF7	; 247
    3524:	80 93 c1 00 	sts	0x00C1, r24
    3528:	9e cf       	rjmp	.-196    	; 0x3466 <__vector_12+0x84>
	switch(line_count){
		case 1:
			if (frame_delay) frame_delay--;
			break;
		case 2:
		if (tone_length){
    352a:	80 91 38 01 	lds	r24, 0x0138
    352e:	88 23       	and	r24, r24
    3530:	09 f4       	brne	.+2      	; 0x3534 <__vector_12+0x152>
    3532:	99 cf       	rjmp	.-206    	; 0x3466 <__vector_12+0x84>
			tone_length--;
    3534:	80 91 38 01 	lds	r24, 0x0138
    3538:	81 50       	subi	r24, 0x01	; 1
    353a:	80 93 38 01 	sts	0x0138, r24
			if (!tone_length) tone_off();
    353e:	80 91 38 01 	lds	r24, 0x0138
    3542:	81 11       	cpse	r24, r1
    3544:	90 cf       	rjmp	.-224    	; 0x3466 <__vector_12+0x84>
    3546:	56 98       	cbi	0x0a, 6	; 10
    3548:	8e cf       	rjmp	.-228    	; 0x3466 <__vector_12+0x84>

0000354a <__udivmodsi4>:
    354a:	a1 e2       	ldi	r26, 0x21	; 33
    354c:	1a 2e       	mov	r1, r26
    354e:	aa 1b       	sub	r26, r26
    3550:	bb 1b       	sub	r27, r27
    3552:	fd 01       	movw	r30, r26
    3554:	0d c0       	rjmp	.+26     	; 0x3570 <__udivmodsi4_ep>

00003556 <__udivmodsi4_loop>:
    3556:	aa 1f       	adc	r26, r26
    3558:	bb 1f       	adc	r27, r27
    355a:	ee 1f       	adc	r30, r30
    355c:	ff 1f       	adc	r31, r31
    355e:	a2 17       	cp	r26, r18
    3560:	b3 07       	cpc	r27, r19
    3562:	e4 07       	cpc	r30, r20
    3564:	f5 07       	cpc	r31, r21
    3566:	20 f0       	brcs	.+8      	; 0x3570 <__udivmodsi4_ep>
    3568:	a2 1b       	sub	r26, r18
    356a:	b3 0b       	sbc	r27, r19
    356c:	e4 0b       	sbc	r30, r20
    356e:	f5 0b       	sbc	r31, r21

00003570 <__udivmodsi4_ep>:
    3570:	66 1f       	adc	r22, r22
    3572:	77 1f       	adc	r23, r23
    3574:	88 1f       	adc	r24, r24
    3576:	99 1f       	adc	r25, r25
    3578:	1a 94       	dec	r1
    357a:	69 f7       	brne	.-38     	; 0x3556 <__udivmodsi4_loop>
    357c:	60 95       	com	r22
    357e:	70 95       	com	r23
    3580:	80 95       	com	r24
    3582:	90 95       	com	r25
    3584:	9b 01       	movw	r18, r22
    3586:	ac 01       	movw	r20, r24
    3588:	bd 01       	movw	r22, r26
    358a:	cf 01       	movw	r24, r30
    358c:	08 95       	ret

0000358e <__divmodsi4>:
    358e:	05 2e       	mov	r0, r21
    3590:	97 fb       	bst	r25, 7
    3592:	1e f4       	brtc	.+6      	; 0x359a <__divmodsi4+0xc>
    3594:	00 94       	com	r0
    3596:	0e 94 de 1a 	call	0x35bc	; 0x35bc <__negsi2>
    359a:	57 fd       	sbrc	r21, 7
    359c:	07 d0       	rcall	.+14     	; 0x35ac <__divmodsi4_neg2>
    359e:	0e 94 a5 1a 	call	0x354a	; 0x354a <__udivmodsi4>
    35a2:	07 fc       	sbrc	r0, 7
    35a4:	03 d0       	rcall	.+6      	; 0x35ac <__divmodsi4_neg2>
    35a6:	4e f4       	brtc	.+18     	; 0x35ba <__divmodsi4_exit>
    35a8:	0c 94 de 1a 	jmp	0x35bc	; 0x35bc <__negsi2>

000035ac <__divmodsi4_neg2>:
    35ac:	50 95       	com	r21
    35ae:	40 95       	com	r20
    35b0:	30 95       	com	r19
    35b2:	21 95       	neg	r18
    35b4:	3f 4f       	sbci	r19, 0xFF	; 255
    35b6:	4f 4f       	sbci	r20, 0xFF	; 255
    35b8:	5f 4f       	sbci	r21, 0xFF	; 255

000035ba <__divmodsi4_exit>:
    35ba:	08 95       	ret

000035bc <__negsi2>:
    35bc:	90 95       	com	r25
    35be:	80 95       	com	r24
    35c0:	70 95       	com	r23
    35c2:	61 95       	neg	r22
    35c4:	7f 4f       	sbci	r23, 0xFF	; 255
    35c6:	8f 4f       	sbci	r24, 0xFF	; 255
    35c8:	9f 4f       	sbci	r25, 0xFF	; 255
    35ca:	08 95       	ret

000035cc <__tablejump2__>:
    35cc:	ee 0f       	add	r30, r30
    35ce:	ff 1f       	adc	r31, r31

000035d0 <__tablejump__>:
    35d0:	05 90       	lpm	r0, Z+
    35d2:	f4 91       	lpm	r31, Z
    35d4:	e0 2d       	mov	r30, r0
    35d6:	09 94       	ijmp

000035d8 <__umulhisi3>:
    35d8:	a2 9f       	mul	r26, r18
    35da:	b0 01       	movw	r22, r0
    35dc:	b3 9f       	mul	r27, r19
    35de:	c0 01       	movw	r24, r0
    35e0:	a3 9f       	mul	r26, r19
    35e2:	70 0d       	add	r23, r0
    35e4:	81 1d       	adc	r24, r1
    35e6:	11 24       	eor	r1, r1
    35e8:	91 1d       	adc	r25, r1
    35ea:	b2 9f       	mul	r27, r18
    35ec:	70 0d       	add	r23, r0
    35ee:	81 1d       	adc	r24, r1
    35f0:	11 24       	eor	r1, r1
    35f2:	91 1d       	adc	r25, r1
    35f4:	08 95       	ret

000035f6 <__muluhisi3>:
    35f6:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <__umulhisi3>
    35fa:	a5 9f       	mul	r26, r21
    35fc:	90 0d       	add	r25, r0
    35fe:	b4 9f       	mul	r27, r20
    3600:	90 0d       	add	r25, r0
    3602:	a4 9f       	mul	r26, r20
    3604:	80 0d       	add	r24, r0
    3606:	91 1d       	adc	r25, r1
    3608:	11 24       	eor	r1, r1
    360a:	08 95       	ret

0000360c <do_rand>:
    360c:	8f 92       	push	r8
    360e:	9f 92       	push	r9
    3610:	af 92       	push	r10
    3612:	bf 92       	push	r11
    3614:	cf 92       	push	r12
    3616:	df 92       	push	r13
    3618:	ef 92       	push	r14
    361a:	ff 92       	push	r15
    361c:	cf 93       	push	r28
    361e:	df 93       	push	r29
    3620:	ec 01       	movw	r28, r24
    3622:	68 81       	ld	r22, Y
    3624:	79 81       	ldd	r23, Y+1	; 0x01
    3626:	8a 81       	ldd	r24, Y+2	; 0x02
    3628:	9b 81       	ldd	r25, Y+3	; 0x03
    362a:	61 15       	cp	r22, r1
    362c:	71 05       	cpc	r23, r1
    362e:	81 05       	cpc	r24, r1
    3630:	91 05       	cpc	r25, r1
    3632:	21 f4       	brne	.+8      	; 0x363c <do_rand+0x30>
    3634:	64 e2       	ldi	r22, 0x24	; 36
    3636:	79 ed       	ldi	r23, 0xD9	; 217
    3638:	8b e5       	ldi	r24, 0x5B	; 91
    363a:	97 e0       	ldi	r25, 0x07	; 7
    363c:	2d e1       	ldi	r18, 0x1D	; 29
    363e:	33 ef       	ldi	r19, 0xF3	; 243
    3640:	41 e0       	ldi	r20, 0x01	; 1
    3642:	50 e0       	ldi	r21, 0x00	; 0
    3644:	0e 94 c7 1a 	call	0x358e	; 0x358e <__divmodsi4>
    3648:	49 01       	movw	r8, r18
    364a:	5a 01       	movw	r10, r20
    364c:	9b 01       	movw	r18, r22
    364e:	ac 01       	movw	r20, r24
    3650:	a7 ea       	ldi	r26, 0xA7	; 167
    3652:	b1 e4       	ldi	r27, 0x41	; 65
    3654:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <__muluhisi3>
    3658:	6b 01       	movw	r12, r22
    365a:	7c 01       	movw	r14, r24
    365c:	ac ee       	ldi	r26, 0xEC	; 236
    365e:	b4 ef       	ldi	r27, 0xF4	; 244
    3660:	a5 01       	movw	r20, r10
    3662:	94 01       	movw	r18, r8
    3664:	0e 94 89 1b 	call	0x3712	; 0x3712 <__mulohisi3>
    3668:	c6 0e       	add	r12, r22
    366a:	d7 1e       	adc	r13, r23
    366c:	e8 1e       	adc	r14, r24
    366e:	f9 1e       	adc	r15, r25
    3670:	f7 fe       	sbrs	r15, 7
    3672:	06 c0       	rjmp	.+12     	; 0x3680 <do_rand+0x74>
    3674:	81 e0       	ldi	r24, 0x01	; 1
    3676:	c8 1a       	sub	r12, r24
    3678:	d1 08       	sbc	r13, r1
    367a:	e1 08       	sbc	r14, r1
    367c:	80 e8       	ldi	r24, 0x80	; 128
    367e:	f8 0a       	sbc	r15, r24
    3680:	c8 82       	st	Y, r12
    3682:	d9 82       	std	Y+1, r13	; 0x01
    3684:	ea 82       	std	Y+2, r14	; 0x02
    3686:	fb 82       	std	Y+3, r15	; 0x03
    3688:	c6 01       	movw	r24, r12
    368a:	9f 77       	andi	r25, 0x7F	; 127
    368c:	df 91       	pop	r29
    368e:	cf 91       	pop	r28
    3690:	ff 90       	pop	r15
    3692:	ef 90       	pop	r14
    3694:	df 90       	pop	r13
    3696:	cf 90       	pop	r12
    3698:	bf 90       	pop	r11
    369a:	af 90       	pop	r10
    369c:	9f 90       	pop	r9
    369e:	8f 90       	pop	r8
    36a0:	08 95       	ret

000036a2 <rand_r>:
    36a2:	0e 94 06 1b 	call	0x360c	; 0x360c <do_rand>
    36a6:	08 95       	ret

000036a8 <rand>:
    36a8:	80 e0       	ldi	r24, 0x00	; 0
    36aa:	91 e0       	ldi	r25, 0x01	; 1
    36ac:	0e 94 06 1b 	call	0x360c	; 0x360c <do_rand>
    36b0:	08 95       	ret

000036b2 <srand>:
    36b2:	a0 e0       	ldi	r26, 0x00	; 0
    36b4:	b0 e0       	ldi	r27, 0x00	; 0
    36b6:	80 93 00 01 	sts	0x0100, r24
    36ba:	90 93 01 01 	sts	0x0101, r25
    36be:	a0 93 02 01 	sts	0x0102, r26
    36c2:	b0 93 03 01 	sts	0x0103, r27
    36c6:	08 95       	ret

000036c8 <memmove>:
    36c8:	68 17       	cp	r22, r24
    36ca:	79 07       	cpc	r23, r25
    36cc:	68 f4       	brcc	.+26     	; 0x36e8 <memmove+0x20>
    36ce:	fb 01       	movw	r30, r22
    36d0:	dc 01       	movw	r26, r24
    36d2:	e4 0f       	add	r30, r20
    36d4:	f5 1f       	adc	r31, r21
    36d6:	a4 0f       	add	r26, r20
    36d8:	b5 1f       	adc	r27, r21
    36da:	02 c0       	rjmp	.+4      	; 0x36e0 <memmove+0x18>
    36dc:	02 90       	ld	r0, -Z
    36de:	0e 92       	st	-X, r0
    36e0:	41 50       	subi	r20, 0x01	; 1
    36e2:	50 40       	sbci	r21, 0x00	; 0
    36e4:	d8 f7       	brcc	.-10     	; 0x36dc <memmove+0x14>
    36e6:	08 95       	ret
    36e8:	0c 94 7d 1b 	jmp	0x36fa	; 0x36fa <memcpy>

000036ec <memset>:
    36ec:	dc 01       	movw	r26, r24
    36ee:	01 c0       	rjmp	.+2      	; 0x36f2 <memset+0x6>
    36f0:	6d 93       	st	X+, r22
    36f2:	41 50       	subi	r20, 0x01	; 1
    36f4:	50 40       	sbci	r21, 0x00	; 0
    36f6:	e0 f7       	brcc	.-8      	; 0x36f0 <memset+0x4>
    36f8:	08 95       	ret

000036fa <memcpy>:
    36fa:	fb 01       	movw	r30, r22
    36fc:	dc 01       	movw	r26, r24
    36fe:	02 c0       	rjmp	.+4      	; 0x3704 <memcpy+0xa>
    3700:	01 90       	ld	r0, Z+
    3702:	0d 92       	st	X+, r0
    3704:	41 50       	subi	r20, 0x01	; 1
    3706:	50 40       	sbci	r21, 0x00	; 0
    3708:	d8 f7       	brcc	.-10     	; 0x3700 <memcpy+0x6>
    370a:	08 95       	ret

0000370c <__mulshisi3>:
    370c:	b7 ff       	sbrs	r27, 7
    370e:	0c 94 fb 1a 	jmp	0x35f6	; 0x35f6 <__muluhisi3>

00003712 <__mulohisi3>:
    3712:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <__muluhisi3>
    3716:	82 1b       	sub	r24, r18
    3718:	93 0b       	sbc	r25, r19
    371a:	08 95       	ret

0000371c <_exit>:
    371c:	f8 94       	cli

0000371e <__stop_program>:
    371e:	ff cf       	rjmp	.-2      	; 0x371e <__stop_program>
